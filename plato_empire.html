<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="description" content="EMPIRE — A faithful recreation of the classic PLATO system space combat game (1973)">
<title>EMPIRE — A PLATO Classic Recreation</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #000;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    overflow: hidden;
    font-family: monospace;
    user-select: none;
  }
  #gameContainer {
    position: relative;
    display: flex;
    flex-direction: column;
    transform-origin: top center;
  }
  #gameCanvas { display: block; cursor: crosshair; }
  #hudCanvas  { display: block; margin-top: 3px; }
  #minimapCanvas {
    position: absolute;
    top: 10px;
    right: 10px;
    pointer-events: none; /* don't intercept mouse/keyboard input */
    image-rendering: pixelated;
  }
</style>
</head>
<body>
<div id="gameContainer">
  <canvas id="gameCanvas"></canvas>
  <canvas id="hudCanvas"></canvas>
  <canvas id="minimapCanvas"></canvas>
</div>
<script>
'use strict';

// =============================================================
// SECTION 1: CONSTANTS & CONFIG
// =============================================================

const GRID_W = 256;           // toroidal world width
const GRID_H = 256;           // toroidal world height

const VIEW_W = 800;           // game canvas pixel width
const VIEW_H = 800;           // game canvas pixel height
const HUD_H  = 80;            // hud strip pixel height

// Zoom: pixels per world unit. 40 world units visible across the view.
const PPU = VIEW_W / 40;      // 20 px per world unit

// Race identifiers
const RACES = { FEDERATION: 0, ROMULAN: 1, ORION: 2, KAZARI: 3 };
const RACE_NAMES   = ['Federation', 'Romulan', 'Orion', 'Kazari'];
const RACE_LETTERS = ['F', 'R', 'O', 'K'];
const RACE_COLORS  = ['#22aaff', '#ff4444', '#ffaa22', '#cc44ff'];

// Phosphor palette sets (orange = PLATO default, green = classic terminal)
const PHOSPHOR = {
  ORANGE: { primary: '#ff9900', glow: '#ff5500', dim: '#331100' },
  GREEN:  { primary: '#33ff66', glow: '#00cc44', dim: '#003311' },
};

// Planet layout
const NUM_PLANETS     = 25;
const CORNER_MARGIN   = 18;   // world units from grid corner for home clusters
const ORBIT_RANGE     = 6;    // world units — planet "in range" for HUD
const LAND_RANGE      = 4;    // world units — close enough to land/beam

// Ship physics
const TURN_RATE      = 2.2;   // radians per second (held key)
const WARP_SPEEDS    = [0, 2, 4, 8, 16, 32, 64, 96, 144, 200]; // world units/sec
const ENERGY_DRAIN   = [0, 1, 2, 4, 8, 16, 32, 48, 72, 100];   // energy/sec per warp
const ENERGY_MAX     = 1000;
const ENERGY_REGEN   = 120;   // energy/sec while landed on friendly planet
const TORPEDO_START  = 10;
const ARMY_START     = 5;

// Combat
const TORPEDO_SPEED      = 90;   // world units/sec
const TORPEDO_RANGE      = 32;   // world units max travel
const TORPEDO_DAMAGE     = 40;   // hull points (direct)
const TORPEDO_SPLASH_R   = 3.5;  // world units radius
const TORPEDO_SPLASH_DMG = 18;   // max splash hull pts
const TORPEDO_COOLDOWN   = 0.5;  // seconds between shots
const TORPEDO_ENERGY     = 15;   // energy per torpedo

const PHASER_RANGE       = 14;   // world units
const PHASER_HALF_ANGLE  = Math.PI / 6; // 30° half-cone
const PHASER_DAMAGE      = 28;   // max hull pts at point-blank
const PHASER_COOLDOWN    = 1.2;  // seconds
const PHASER_ENERGY      = 35;   // energy per burst
const PHASER_FX_DURATION = 0.35; // seconds phaser arc is visible

// Hull health thresholds (hull=100 is full health, 0=dead)
const THRESH_SHIELDS = 75; // hull below this → shields degraded
const THRESH_WEAPONS = 50; // hull below this → weapons degraded
const THRESH_ENGINES = 25; // hull below this → engines degraded

// Planet economy
const ARMY_REGEN_INTERVAL = 18; // seconds per new army on owned planet
const PLANET_ARMY_MAX     = 20;
const REPAIR_RATE         = 8;  // hull pts restored per second while repairing
const REPAIR_ENERGY_COST  = 12; // energy/sec consumed while repairing

// AI tuning
const AI_SCAN_RADIUS     = 45;  // world units AI "sensor" range
const AI_DECISION_RATE   = 0.6; // seconds between AI decisions
const AI_ATTACK_HULL_MIN = 40;  // hull % below which AI retreats
const AI_ARMY_THRESHOLD  = 6;   // armies needed before AI tries to conquer

// Physics step
const PHYSICS_STEP = 1 / 60;   // fixed 60 Hz physics

// Mini-map dimensions
const MM_SIZE      = 150;            // square map area (pixels)
const MM_LABEL_H   = 16;            // space above map for "SECTOR MAP" label
const MM_CANVAS_H  = MM_LABEL_H + MM_SIZE; // total canvas height
const MM_SCALE     = MM_SIZE / GRID_W;     // world unit → minimap pixel

// Race-specific stat modifiers  [speedMult, hullMult, weaponMult, energyMult]
const RACE_MODS = [
  { speedMult: 1.0,  hullMult: 1.0,  weaponMult: 1.0,  energyMult: 1.0 }, // Federation: balanced
  { speedMult: 1.2,  hullMult: 0.85, weaponMult: 1.0,  energyMult: 1.0 }, // Romulan: fast, fragile
  { speedMult: 1.0,  hullMult: 1.0,  weaponMult: 1.25, energyMult: 0.8 }, // Orion: hard punch, low energy
  { speedMult: 0.8,  hullMult: 1.3,  weaponMult: 1.0,  energyMult: 1.0 }, // Kazari: armored, slow
];
const RACE_FLAVOR = [
  'Defenders of order. Balanced and resilient.',
  'Masters of stealth. Fast and aggressive.',
  'Pirates of the void. High risk, high reward.',
  'Ancient warriors. Heavy armor, slow speed.',
];
// 3-line ASCII ship art per race
const RACE_SHIP_ART = [
  ['  /\\  ', ' /==\\ ', '/====\\'],   // Federation
  [' \\ / ', '=>-<= ', ' / \\ '],    // Romulan (Bird of Prey)
  ['  |>> ', '/====> ', ' \\__/ '],  // Orion (pirate raider)
  ['[####]', '[====] ', '[####]'],  // Kazari (heavy plated)
];

// Transition / cinematic timing
const FADE_DURATION       = 0.5;   // seconds for fade in/out
const CINEMATIC_DURATION  = 4.5;   // seconds for text crawl screen

// Hall of Fame / Scoring
const SCORE_PLANET    = 100;   // per planet conquered
const SCORE_KILL      = 250;   // per enemy ship destroyed
const SCORE_WIN_BONUS = 2000;  // awarded on total victory
const SCORE_ARMY_LOST = -5;    // per army lost in a failed assault
const SCORE_DEATH     = -500;  // penalty for ship destruction
const HOF_KEY         = 'plato_empire_hof';
const HOF_MAX         = 10;


// =============================================================
// SECTION 2: GAME STATE
// =============================================================

// --- Factory functions ---

function createShip(race, x, y, isPlayer) {
  const mod      = RACE_MODS[race] || RACE_MODS[0];
  const hullMax  = Math.round(100       * mod.hullMult);
  const energyMax = Math.round(ENERGY_MAX * mod.energyMult);
  return {
    race, isPlayer, alive: true,
    x, y,
    heading: 0,           // radians (0 = right, PI/2 = down)
    warp: 0,
    hull: hullMax,        // starts full; 0 = destroyed
    hullMax,
    shields: 100,         // 0-100 absorb rating
    energy: energyMax,
    energyMax,
    speedMult:  mod.speedMult,   // applied to WARP_SPEEDS lookup
    weaponMult: mod.weaponMult,  // applied to torpedo + phaser damage
    torpedoes: TORPEDO_START,
    armies: ARMY_START,
    torpedoCooldown: 0,
    phaserCooldown: 0,
    repairing: false,
    landedOn: null,       // planet object or null
    trail: [],            // [{x,y,age}]
    // Computed damage flags (updated each tick)
    shieldsDown: false,
    weaponsDown: false,
    enginesDown: false,
    // AI brain (null for player)
    ai: isPlayer ? null : createAI(),
  };
}

function createPlanet(id, x, y, race, isHome) {
  const def = isHome
    ? 8
    : Math.floor(Math.random() * 8) + 1;
  return {
    id, x, y,
    race,               // null = neutral
    isHome,
    defense: def,
    armies: isHome ? 4 : Math.floor(Math.random() * 3),
    armyRegenTimer: Math.random() * ARMY_REGEN_INTERVAL,
    flickerPhase: Math.random() * Math.PI * 2,
  };
}

function createTorpedo(ownerRace, x, y, heading) {
  return {
    ownerRace, x, y, heading,
    prevX: x, prevY: y,
    distanceTraveled: 0,
    alive: true,
  };
}

function createPhaserFX(x, y, heading) {
  return { x, y, heading, age: 0, ownerRace: 0 };
}

function createAI() {
  return {
    state: 'PATROL',       // PATROL | ATTACK | RETREAT | CONQUER
    targetShip: null,
    targetPlanet: null,
    waypointX: Math.random() * GRID_W,
    waypointY: Math.random() * GRID_H,
    decisionTimer: Math.random() * AI_DECISION_RATE,
  };
}

// --- Master state object ---
const G = {
  ships:    [],
  planets:  [],
  torpedoes:[],
  phaserFX: [],
  player:   null,
  playerRace: 0,
  phosphorMode: 'ORANGE',
  phase: 'TITLE',         // TITLE | RACE_SELECT | PLAYING | WIN | CINEMATIC | NAME_ENTRY | HALL_OF_FAME | INSTRUCTIONS
  keys: {},
  messages: [],           // [{text, age, duration}]
  stars: [],
  // Canvases / contexts (set in init)
  ctx: null,
  hudCtx: null,
  mmCtx: null,          // minimap canvas context
  minimapVisible: true, // toggled with M key
  // Timing
  lastTimestamp: 0,
  physicsAccum: 0,
  gameTime: 0,
  // Self-destruct state for player
  selfDestructArmed: false,
  selfDestructTimer: 0,
  // Race select highlight
  raceSelectHover: 0,
  // Scoring / Hall of Fame
  score: 0,
  kills: 0,
  armiesLost: 0,
  gameWon: false,
  hof: [],              // top-10 entries loaded from localStorage
  hofResumePhase: null, // phase to return to when dismissing HoF mid-game
  nameText: '',         // player's name being typed on NAME_ENTRY screen
  // Title screen
  titleStars: [],       // [{x,y,speed,brightness}] drifting down the title screen
  // Instructions overlay
  instructionsPage: 0,  // 0 or 1
  instructionsResume: 'TITLE', // phase to return to on dismiss
  // Fade transitions
  fadeAlpha: 0,
  fadeDir: 0,           // 0=idle, -1=fading-out, +1=fading-in
  fadeElapsed: 0,
  fadeTarget: null,     // phase to switch to when black
  fadeCallback: null,   // optional function called at moment of phase switch
  // Cinematic text crawl (shown before NAME_ENTRY)
  cinematicAge: 0,
  cinematicText: '',
};


// =============================================================
// SECTION 3: INPUT HANDLING
// =============================================================

const KEY_MAP = {
  'ArrowUp':    'thrustUp',
  'ArrowDown':  'thrustDown',
  'ArrowLeft':  'turnLeft',
  'ArrowRight': 'turnRight',
  'KeyW': 'thrustUp',
  'KeyS': 'thrustDown',
  'KeyA': 'turnLeft',
  'KeyD': 'turnRight',
  'KeyT': 'torpedo',
  'KeyP': 'phasers',
  'KeyL': 'land',
  'KeyB': 'beam',
  'KeyR': 'repair',
  'KeyQ': 'selfDestruct',
  'KeyG': 'togglePhosphor',
  'Digit0': 'warp0', 'Digit1': 'warp1', 'Digit2': 'warp2',
  'Digit3': 'warp3', 'Digit4': 'warp4', 'Digit5': 'warp5',
  'Digit6': 'warp6', 'Digit7': 'warp7', 'Digit8': 'warp8',
  'Digit9': 'warp9',
  'KeyM': 'toggleMinimap',
  'KeyV': 'toggleSound',
  'BracketLeft':  'volumeDown',
  'BracketRight': 'volumeUp',
  'KeyH': 'hallOfFame',
};

document.addEventListener('keydown', e => {
  // Always prevent Tab from leaving canvas focus
  if (e.code === 'Tab') { e.preventDefault(); return; }

  // Bootstrap AudioContext on very first keypress (browser autoplay policy)
  SoundManager.init();

  // TITLE screen
  if (G.phase === 'TITLE') {
    e.preventDefault();
    if (e.code === 'Enter') {
      startFade('RACE_SELECT');
    } else if (e.code === 'KeyI') {
      G.instructionsResume = 'TITLE';
      startFade('INSTRUCTIONS');
    }
    return;
  }

  // CINEMATIC: any key skips the crawl
  if (G.phase === 'CINEMATIC') {
    e.preventDefault();
    G.phase = 'NAME_ENTRY';
    return;
  }

  // NAME_ENTRY: intercept raw key events — bypass KEY_MAP entirely
  if (G.phase === 'NAME_ENTRY') {
    e.preventDefault();
    if (e.code === 'Enter') {
      commitNameEntry();
    } else if (e.code === 'Backspace') {
      G.nameText = G.nameText.slice(0, -1);
    } else if (e.key.length === 1 && G.nameText.length < 12) {
      G.nameText = (G.nameText + e.key).toUpperCase();
    }
    return;
  }

  // HALL_OF_FAME: any key dismisses and returns to resume phase
  if (G.phase === 'HALL_OF_FAME') {
    e.preventDefault();
    dismissHallOfFame();
    return;
  }

  // INSTRUCTIONS overlay: navigate pages or dismiss
  if (G.phase === 'INSTRUCTIONS') {
    e.preventDefault();
    if (e.code === 'ArrowRight' || e.code === 'ArrowDown' || e.code === 'PageDown') {
      G.instructionsPage = Math.min(1, G.instructionsPage + 1);
    } else if (e.code === 'ArrowLeft' || e.code === 'ArrowUp' || e.code === 'PageUp') {
      G.instructionsPage = Math.max(0, G.instructionsPage - 1);
    } else if (e.code === 'Escape' || e.code === 'KeyI') {
      startFade(G.instructionsResume || 'TITLE');
    }
    return;
  }

  const action = KEY_MAP[e.code];
  if (!action) return;
  e.preventDefault();

  // Sound controls work in all phases
  if (action === 'toggleSound') {
    SoundManager.toggleMute();
    addMessage(SoundManager.muted ? 'SOUND: OFF' : 'SOUND: ON');
    return;
  }
  if (action === 'volumeDown') {
    SoundManager.setVolume(SoundManager.volume - 0.1);
    addMessage(`VOLUME: ${Math.round(SoundManager.volume * 10)}/10`);
    return;
  }
  if (action === 'volumeUp') {
    SoundManager.setVolume(SoundManager.volume + 0.1);
    addMessage(`VOLUME: ${Math.round(SoundManager.volume * 10)}/10`);
    return;
  }

  // M = toggle minimap works in all phases
  if (action === 'toggleMinimap') {
    G.minimapVisible = !G.minimapVisible;
    const mmEl = document.getElementById('minimapCanvas');
    if (mmEl) mmEl.style.display = G.minimapVisible ? 'block' : 'none';
    return;
  }

  // RACE_SELECT screen: arrow keys to navigate, Enter to confirm, digits as shortcuts
  if (G.phase === 'RACE_SELECT') {
    if (action === 'turnLeft' || action === 'thrustUp') {
      G.raceSelectHover = (G.raceSelectHover + 3) % 4;
    } else if (action === 'turnRight' || action === 'thrustDown') {
      G.raceSelectHover = (G.raceSelectHover + 1) % 4;
    } else if (e.code === 'Enter') {
      startFade('PLAYING', () => startGame(G.raceSelectHover));
    } else if (e.code === 'Digit1') { G.raceSelectHover = 0; startFade('PLAYING', () => startGame(0)); }
    else if (e.code === 'Digit2') { G.raceSelectHover = 1; startFade('PLAYING', () => startGame(1)); }
    else if (e.code === 'Digit3') { G.raceSelectHover = 2; startFade('PLAYING', () => startGame(2)); }
    else if (e.code === 'Digit4') { G.raceSelectHover = 3; startFade('PLAYING', () => startGame(3)); }
    else if (action === 'hallOfFame') openHallOfFame('RACE_SELECT');
    else if (e.code === 'KeyI') { G.instructionsResume = 'RACE_SELECT'; startFade('INSTRUCTIONS'); }
    return;
  }

  // WIN: any key skips to cinematic (set text here in case timeout hasn't fired yet)
  if (G.phase === 'WIN') {
    G.cinematicText = `The galaxy bows to ${RACE_NAMES[G.playerRace]} supremacy. Your name will echo across the stars.`;
    G.cinematicAge  = 0;
    G.phase = 'CINEMATIC';
    return;
  }

  if (G.phase !== 'PLAYING') return;

  // Mark key held
  G.keys[action] = true;

  // One-shot discrete actions
  if (action.startsWith('warp')) {
    const n = parseInt(action.slice(4));
    setWarp(G.player, n);
  }
  if (action === 'thrustUp')   setWarp(G.player, Math.min(9, G.player.warp + 1));
  if (action === 'thrustDown') setWarp(G.player, Math.max(0, G.player.warp - 1));
  if (action === 'torpedo')    fireTorpedo(G.player);
  if (action === 'phasers')    firePhasers(G.player);
  if (action === 'land')       tryLand(G.player);
  if (action === 'beam')       tryBeam(G.player);
  if (action === 'repair')     toggleRepair(G.player);
  if (action === 'selfDestruct') handleSelfDestruct(G.player);
  if (action === 'togglePhosphor') {
    G.phosphorMode = G.phosphorMode === 'ORANGE' ? 'GREEN' : 'ORANGE';
    addMessage('PHOSPHOR: ' + G.phosphorMode);
  }
  if (action === 'hallOfFame') openHallOfFame('PLAYING');
  if (e.code === 'KeyI') {
    G.instructionsResume = 'PLAYING';
    startFade('INSTRUCTIONS');
  }
});

document.addEventListener('keyup', e => {
  const action = KEY_MAP[e.code];
  if (action) G.keys[action] = false;
});

function setWarp(ship, n) {
  if (ship.enginesDown && n > 2) {
    n = 2;
    addMessage('ENGINES DAMAGED — WARP LIMITED');
  }
  if (ship.energy <= 0 && n > 0) {
    addMessage('INSUFFICIENT ENERGY');
    return;
  }
  // Lift off planet when changing warp
  if (n > 0 && ship.landedOn) {
    ship.landedOn = null;
    ship.repairing = false;
    addMessage('DEPARTED ORBIT');
  }
  ship.warp = n;
  if (ship.isPlayer) SoundManager.warpChange(n);
}

function handleSelfDestruct(ship) {
  if (!G.selfDestructArmed) {
    G.selfDestructArmed = true;
    G.selfDestructTimer = 3;
    addMessage('SELF-DESTRUCT ARMED — PRESS Q AGAIN TO CONFIRM');
  } else {
    addMessage('SELF-DESTRUCT INITIATED!');
    // Create a big splash
    torpedoSplash(ship.x, ship.y, -1); // -1 race = hits everyone
    destroyShip(ship);
    G.selfDestructArmed = false;
  }
}

function processInput(ship, dt) {
  if (!ship.isPlayer || !ship.alive) return;
  if (ship.landedOn) return;
  if (G.keys.turnLeft)  ship.heading -= TURN_RATE * dt;
  if (G.keys.turnRight) ship.heading += TURN_RATE * dt;
  // Normalize heading
  ship.heading = ((ship.heading % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
}


// =============================================================
// SECTION 3.5: SOUND SYSTEM (Web Audio API)
// =============================================================

const SoundManager = {
  ctx:    null,   // AudioContext (lazy-init on first keypress)
  master: null,   // GainNode — master volume
  volume: 0.5,    // 0.0–1.0
  muted:  false,

  // Torpedo: max 3 simultaneous instances
  torpedoCount: 0,

  // Low-energy warning (managed loop)
  lowEnergyActive:  false,
  lowEnergyTimeout: null,

  // Create AudioContext on first user interaction (browser autoplay policy)
  init() {
    if (this.ctx) return;
    try {
      this.ctx    = new (window.AudioContext || window.webkitAudioContext)();
      this.master = this.ctx.createGain();
      this.master.gain.value = this.volume;
      this.master.connect(this.ctx.destination);
    } catch (e) {
      this.ctx = null; // audio not available
    }
  },

  // Connect a node to master output
  _out(node) {
    if (this.master) node.connect(this.master);
  },

  // Guard: returns false if sound should not play
  _ok() {
    return this.ctx && !this.muted;
  },

  setVolume(v) {
    this.volume = Math.max(0, Math.min(1, v));
    if (this.master) this.master.gain.value = this.muted ? 0 : this.volume;
  },

  toggleMute() {
    this.muted = !this.muted;
    if (this.master) this.master.gain.value = this.muted ? 0 : this.volume;
    if (this.muted) this.stopLowEnergyWarning();
  },

  // ---- Torpedo fire: sawtooth 200→400 Hz over 150 ms ----
  torpedo() {
    if (!this._ok() || this.torpedoCount >= 3) return;
    this.torpedoCount++;
    const now = this.ctx.currentTime;
    const osc  = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(200, now);
    osc.frequency.linearRampToValueAtTime(400, now + 0.15);
    gain.gain.setValueAtTime(0.38, now);
    gain.gain.linearRampToValueAtTime(0.001, now + 0.18);
    osc.connect(gain);
    this._out(gain);
    osc.start(now);
    osc.stop(now + 0.18);
    osc.onended = () => { this.torpedoCount = Math.max(0, this.torpedoCount - 1); };
  },

  // ---- Torpedo impact: white noise burst + low rumble ----
  explosion() {
    if (!this._ok()) return;
    const now = this.ctx.currentTime;

    // White noise burst (300 ms)
    const bufLen   = Math.ceil(this.ctx.sampleRate * 0.3);
    const buffer   = this.ctx.createBuffer(1, bufLen, this.ctx.sampleRate);
    const data     = buffer.getChannelData(0);
    for (let i = 0; i < bufLen; i++) data[i] = Math.random() * 2 - 1;
    const noise     = this.ctx.createBufferSource();
    noise.buffer    = buffer;
    const noiseGain = this.ctx.createGain();
    noiseGain.gain.setValueAtTime(0.55, now);
    noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
    noise.connect(noiseGain);
    this._out(noiseGain);
    noise.start(now);

    // Low rumble (60 Hz sine, 200 ms)
    const rumble     = this.ctx.createOscillator();
    const rumbleGain = this.ctx.createGain();
    rumble.type = 'sine';
    rumble.frequency.value = 60;
    rumbleGain.gain.setValueAtTime(0.45, now);
    rumbleGain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
    rumble.connect(rumbleGain);
    this._out(rumbleGain);
    rumble.start(now);
    rumble.stop(now + 0.2);
  },

  // ---- Phaser fire: sine 800→200 Hz with 80 ms echo ----
  phaser() {
    if (!this._ok()) return;
    const now = this.ctx.currentTime;
    const dur = 0.2;

    const osc  = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(800, now);
    osc.frequency.linearRampToValueAtTime(200, now + dur);
    gain.gain.setValueAtTime(0.32, now);
    gain.gain.linearRampToValueAtTime(0.001, now + dur + 0.2);

    // Delay / echo chain
    const delay    = this.ctx.createDelay(0.5);
    delay.delayTime.value = 0.08;
    const feedback = this.ctx.createGain();
    feedback.gain.value = 0.3;
    const wetGain  = this.ctx.createGain();
    wetGain.gain.value = 0.45;

    osc.connect(gain);
    gain.connect(this.master);   // dry
    gain.connect(delay);
    delay.connect(feedback);
    feedback.connect(delay);     // feedback loop
    delay.connect(wetGain);
    wetGain.connect(this.master); // wet

    osc.start(now);
    osc.stop(now + dur + 0.5);   // let echo ring out
  },

  // ---- Damage received: AM square wave buzz ----
  damage() {
    if (!this._ok()) return;
    const now = this.ctx.currentTime;
    const dur = 0.4;

    const carrier  = this.ctx.createOscillator();
    carrier.type   = 'square';
    carrier.frequency.value = 150;

    const modOsc   = this.ctx.createOscillator();
    modOsc.type    = 'sine';
    modOsc.frequency.value = 20;  // 20 Hz AM

    const modDepth = this.ctx.createGain();
    modDepth.gain.value = 0.18;   // ± modulation depth

    const envGain  = this.ctx.createGain();
    envGain.gain.setValueAtTime(0.28, now);
    envGain.gain.linearRampToValueAtTime(0.001, now + dur);

    // AM: modulator drives the envelope gain's audio-rate offset
    modOsc.connect(modDepth);
    modDepth.connect(envGain.gain);

    carrier.connect(envGain);
    this._out(envGain);

    carrier.start(now); carrier.stop(now + dur);
    modOsc.start(now);  modOsc.stop(now + dur);
  },

  // ---- Ship destroyed: descending tone + noise burst ----
  shipDestroyed() {
    if (!this._ok()) return;
    const now = this.ctx.currentTime;

    // Descending sine tone 500→50 Hz over 800 ms
    const tone     = this.ctx.createOscillator();
    const toneGain = this.ctx.createGain();
    tone.type = 'sine';
    tone.frequency.setValueAtTime(500, now);
    tone.frequency.exponentialRampToValueAtTime(50, now + 0.8);
    toneGain.gain.setValueAtTime(0.4, now);
    toneGain.gain.linearRampToValueAtTime(0.001, now + 0.8);
    tone.connect(toneGain);
    this._out(toneGain);
    tone.start(now);
    tone.stop(now + 0.8);

    // White noise burst fading over 500 ms
    const bufLen   = Math.ceil(this.ctx.sampleRate * 0.5);
    const buffer   = this.ctx.createBuffer(1, bufLen, this.ctx.sampleRate);
    const data     = buffer.getChannelData(0);
    for (let i = 0; i < bufLen; i++) data[i] = Math.random() * 2 - 1;
    const noise     = this.ctx.createBufferSource();
    noise.buffer    = buffer;
    const noiseGain = this.ctx.createGain();
    noiseGain.gain.setValueAtTime(0.3, now);
    noiseGain.gain.linearRampToValueAtTime(0.001, now + 0.5);
    noise.connect(noiseGain);
    this._out(noiseGain);
    noise.start(now);
  },

  // ---- Planet conquered: ascending C4-E4-G4-C5 arpeggio ----
  planetConquered() {
    if (!this._ok()) return;
    const now   = this.ctx.currentTime;
    const notes = [261.63, 329.63, 392.0, 523.25]; // C4 E4 G4 C5

    notes.forEach((freq, i) => {
      const t    = now + i * 0.1;
      const osc  = this.ctx.createOscillator();
      const gain = this.ctx.createGain();
      osc.type = 'sine';
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(0.28, t + 0.012); // attack
      gain.gain.linearRampToValueAtTime(0.001, t + 0.1);  // decay
      osc.connect(gain);
      this._out(gain);
      osc.start(t);
      osc.stop(t + 0.12);
    });
  },

  // ---- Landing: sine 400→200 Hz with soft attack ----
  landing() {
    if (!this._ok()) return;
    const now  = this.ctx.currentTime;
    const dur  = 0.3;
    const osc  = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(400, now);
    osc.frequency.linearRampToValueAtTime(200, now + dur);
    gain.gain.setValueAtTime(0, now);
    gain.gain.linearRampToValueAtTime(0.28, now + 0.025);
    gain.gain.linearRampToValueAtTime(0.001, now + dur);
    osc.connect(gain);
    this._out(gain);
    osc.start(now);
    osc.stop(now + dur);
  },

  // ---- Warp speed change: short sine blip, pitch scales with warp ----
  warpChange(warpLevel) {
    if (!this._ok()) return;
    const now  = this.ctx.currentTime;
    const freq = 300 + (warpLevel / 9) * 300; // 300 Hz at warp 0 → 600 Hz at warp 9
    const osc  = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = 'sine';
    osc.frequency.value = freq;
    gain.gain.setValueAtTime(0.18, now);
    gain.gain.linearRampToValueAtTime(0.001, now + 0.08);
    osc.connect(gain);
    this._out(gain);
    osc.start(now);
    osc.stop(now + 0.1);
  },

  // ---- Low energy warning: 880 Hz beep, 100 ms on / 900 ms off ----
  startLowEnergyWarning() {
    if (this.lowEnergyActive) return;
    this.lowEnergyActive = true;
    this._tickLowEnergy();
  },

  stopLowEnergyWarning() {
    this.lowEnergyActive = false;
    if (this.lowEnergyTimeout !== null) {
      clearTimeout(this.lowEnergyTimeout);
      this.lowEnergyTimeout = null;
    }
  },

  _tickLowEnergy() {
    if (!this.lowEnergyActive || !this._ok()) return;
    const now  = this.ctx.currentTime;
    const osc  = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = 'sine';
    osc.frequency.value = 880;
    gain.gain.setValueAtTime(0.22, now);
    gain.gain.linearRampToValueAtTime(0.001, now + 0.1);
    osc.connect(gain);
    this._out(gain);
    osc.start(now);
    osc.stop(now + 0.1);
    // 100 ms on + 900 ms off = 1000 ms period
    this.lowEnergyTimeout = setTimeout(() => this._tickLowEnergy(), 1000);
  },
};


// =============================================================
// SECTION 4: PHYSICS & MOVEMENT
// =============================================================

// --- Toroidal math ---

function wrapCoord(v, max) {
  return ((v % max) + max) % max;
}

function toroidalDist(ax, ay, bx, by) {
  let dx = Math.abs(bx - ax);
  let dy = Math.abs(by - ay);
  if (dx > GRID_W / 2) dx = GRID_W - dx;
  if (dy > GRID_H / 2) dy = GRID_H - dy;
  return Math.sqrt(dx * dx + dy * dy);
}

// Returns shortest-path delta from a→b (toroidal)
function toroidalDelta(ax, ay, bx, by) {
  let dx = bx - ax;
  let dy = by - ay;
  if (dx >  GRID_W / 2) dx -= GRID_W;
  if (dx < -GRID_W / 2) dx += GRID_W;
  if (dy >  GRID_H / 2) dy -= GRID_H;
  if (dy < -GRID_H / 2) dy += GRID_H;
  return { dx, dy };
}

// Convert world coords to canvas screen coords (player always centred)
function worldToScreen(wx, wy) {
  const camX = G.player ? G.player.x : GRID_W / 2;
  const camY = G.player ? G.player.y : GRID_H / 2;
  const { dx, dy } = toroidalDelta(camX, camY, wx, wy);
  return {
    sx: VIEW_W / 2 + dx * PPU,
    sy: VIEW_H / 2 + dy * PPU,
  };
}

// Call drawFn(sx,sy) for each ghost copy that falls within the viewport
function drawAtWrapped(wx, wy, drawFn) {
  const offsets = [
    [0,0],[GRID_W,0],[-GRID_W,0],
    [0,GRID_H],[0,-GRID_H],
    [GRID_W,GRID_H],[-GRID_W,GRID_H],
    [GRID_W,-GRID_H],[-GRID_W,-GRID_H],
  ];
  const margin = 60;
  for (const [ox, oy] of offsets) {
    const { sx, sy } = worldToScreen(wx + ox, wy + oy);
    if (sx > -margin && sx < VIEW_W + margin && sy > -margin && sy < VIEW_H + margin) {
      drawFn(sx, sy);
    }
  }
}

// --- Ship update ---

function updateShip(ship, dt) {
  if (!ship.alive) return;

  // Self-destruct timer for AI (handled in AI section)
  // For player, handled separately

  // If landed on planet: skip movement, handle repair/regen
  if (ship.landedOn) {
    const planet = ship.landedOn;
    // If planet captured by enemy, eject
    if (planet.race !== ship.race) {
      ship.landedOn = null;
      if (ship.isPlayer) addMessage('PLANET LOST — EJECTED FROM ORBIT');
    } else {
      // Energy regen
      ship.energy = Math.min(ship.energyMax || ENERGY_MAX, ship.energy + ENERGY_REGEN * dt);
      // Repair
      if (ship.repairing && ship.energy > 10) {
        ship.hull = Math.min(ship.hullMax || 100, ship.hull + REPAIR_RATE * dt);
        ship.energy -= REPAIR_ENERGY_COST * dt;
      }
    }
    // Update damage flags even while landed
    updateDamageFlags(ship);
    updateCooldowns(ship, dt);
    return;
  }

  // Movement — combine engine-damage penalty with race speed multiplier
  const engineMult = ship.enginesDown ? 0.3 : 1.0;
  const speed = WARP_SPEEDS[ship.warp] * engineMult * (ship.speedMult || 1);

  ship.x += Math.cos(ship.heading) * speed * dt;
  ship.y += Math.sin(ship.heading) * speed * dt;
  ship.x = wrapCoord(ship.x, GRID_W);
  ship.y = wrapCoord(ship.y, GRID_H);

  // Energy drain
  ship.energy -= ENERGY_DRAIN[ship.warp] * dt;
  if (ship.energy < 0) {
    ship.energy = 0;
    if (ship.warp > 0) {
      ship.warp = 0;
      if (ship.isPlayer) addMessage('ENERGY DEPLETED — WARP OFFLINE');
    }
  }

  // Trail
  if (ship.warp > 0) {
    ship.trail.push({ x: ship.x, y: ship.y, age: 0 });
    if (ship.trail.length > 22) ship.trail.shift();
  }
  for (const pt of ship.trail) pt.age += dt;

  updateDamageFlags(ship);
  updateCooldowns(ship, dt);
}

function updateDamageFlags(ship) {
  const hullPct = ship.hull / (ship.hullMax || 100) * 100;
  ship.shieldsDown = hullPct < THRESH_SHIELDS;
  ship.weaponsDown = hullPct < THRESH_WEAPONS;
  ship.enginesDown = hullPct < THRESH_ENGINES;
}

function updateCooldowns(ship, dt) {
  if (ship.torpedoCooldown > 0) ship.torpedoCooldown -= dt;
  if (ship.phaserCooldown  > 0) ship.phaserCooldown  -= dt;
}


// =============================================================
// SECTION 5: COMBAT SYSTEM
// =============================================================

function fireTorpedo(ship) {
  if (!ship.alive || ship.landedOn) return;
  if (ship.weaponsDown) { if (ship.isPlayer) addMessage('WEAPONS OFFLINE'); return; }
  if (ship.torpedoes <= 0) { if (ship.isPlayer) addMessage('NO TORPEDOES'); return; }
  if (ship.torpedoCooldown > 0) return;
  if (ship.energy < TORPEDO_ENERGY) { if (ship.isPlayer) addMessage('INSUFFICIENT ENERGY'); return; }

  ship.torpedoes--;
  ship.energy -= TORPEDO_ENERGY;
  ship.torpedoCooldown = TORPEDO_COOLDOWN;

  const torp = createTorpedo(ship.race, ship.x, ship.y, ship.heading);
  torp.dmgMult = ship.weaponMult || 1;
  G.torpedoes.push(torp);
  if (ship.isPlayer) SoundManager.torpedo();
}

function firePhasers(ship) {
  if (!ship.alive || ship.landedOn) return;
  if (ship.weaponsDown) { if (ship.isPlayer) addMessage('WEAPONS OFFLINE'); return; }
  if (ship.phaserCooldown > 0) return;
  if (ship.energy < PHASER_ENERGY) { if (ship.isPlayer) addMessage('INSUFFICIENT ENERGY'); return; }

  ship.energy -= PHASER_ENERGY;
  ship.phaserCooldown = PHASER_COOLDOWN;

  const fx = createPhaserFX(ship.x, ship.y, ship.heading);
  fx.ownerRace = ship.race;
  G.phaserFX.push(fx);
  if (ship.isPlayer) SoundManager.phaser();

  // Instant hit: check all enemy ships in cone
  for (const target of G.ships) {
    if (!target.alive) continue;
    if (target.race === ship.race) continue;

    const d = toroidalDist(ship.x, ship.y, target.x, target.y);
    if (d > PHASER_RANGE) continue;

    const { dx, dy } = toroidalDelta(ship.x, ship.y, target.x, target.y);
    const angleToTarget = Math.atan2(dy, dx);
    let angleDiff = angleToTarget - ship.heading;
    while (angleDiff >  Math.PI) angleDiff -= Math.PI * 2;
    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

    if (Math.abs(angleDiff) <= PHASER_HALF_ANGLE) {
      const falloff = 1 - d / PHASER_RANGE;
      applyDamage(target, PHASER_DAMAGE * falloff * (ship.weaponMult || 1), ship.race);
    }
  }
}

function updateTorpedoes(dt) {
  for (const torp of G.torpedoes) {
    if (!torp.alive) continue;

    torp.prevX = torp.x;
    torp.prevY = torp.y;

    const dist = TORPEDO_SPEED * dt;
    torp.x += Math.cos(torp.heading) * dist;
    torp.y += Math.sin(torp.heading) * dist;
    torp.x = wrapCoord(torp.x, GRID_W);
    torp.y = wrapCoord(torp.y, GRID_H);
    torp.distanceTraveled += dist;

    if (torp.distanceTraveled >= TORPEDO_RANGE) {
      torp.alive = false;
      continue;
    }

    // Ship collision (direct hit)
    let hit = false;
    for (const ship of G.ships) {
      if (!ship.alive) continue;
      if (ship.race === torp.ownerRace) continue;

      const d = toroidalDist(torp.x, torp.y, ship.x, ship.y);
      if (d < 1.8) {
        applyDamage(ship, TORPEDO_DAMAGE * (torp.dmgMult || 1), torp.ownerRace);
        torpedoSplash(torp.x, torp.y, torp.ownerRace, torp.dmgMult || 1);
        SoundManager.explosion();
        torp.alive = false;
        hit = true;
        break;
      }
    }
    if (hit) continue;

    // Planet collision (detonate but no planet damage)
    for (const planet of G.planets) {
      const d = toroidalDist(torp.x, torp.y, planet.x, planet.y);
      if (d < 1.2) {
        torpedoSplash(torp.x, torp.y, torp.ownerRace, torp.dmgMult || 1);
        SoundManager.explosion();
        torp.alive = false;
        break;
      }
    }
  }

  G.torpedoes = G.torpedoes.filter(t => t.alive);
}

function torpedoSplash(cx, cy, ownerRace, dmgMult = 1) {
  for (const ship of G.ships) {
    if (!ship.alive) continue;
    if (ownerRace !== -1 && ship.race === ownerRace) continue;

    const d = toroidalDist(cx, cy, ship.x, ship.y);
    if (d < TORPEDO_SPLASH_R) {
      const falloff = 1 - d / TORPEDO_SPLASH_R;
      applyDamage(ship, TORPEDO_SPLASH_DMG * falloff * dmgMult, ownerRace);
    }
  }
}

function applyDamage(ship, amount, attackerRace = -1) {
  if (!ship.alive) return;

  // Capture pre-damage flag state for change detection
  const prevShieldsDown = ship.shieldsDown;
  const prevWeaponsDown = ship.weaponsDown;
  const prevEnginesDown = ship.enginesDown;

  // Shields absorb portion of damage while operational
  if (!ship.shieldsDown && ship.shields > 0) {
    const absorbed = Math.min(ship.shields, amount * 0.55);
    ship.shields -= absorbed;
    amount -= absorbed;
  }

  ship.hull -= amount;
  if (ship.hull < 0) ship.hull = 0;

  updateDamageFlags(ship);

  if (ship.hull <= 0) {
    // Award kill score if the player destroyed an enemy ship
    if (attackerRace === G.playerRace && !ship.isPlayer) {
      G.score += SCORE_KILL;
      G.kills += 1;
      addMessage(`ENEMY ${RACE_NAMES[ship.race].toUpperCase()} DESTROYED! +${SCORE_KILL} PTS`);
    }
    destroyShip(ship);
  } else if (ship.isPlayer) {
    SoundManager.damage();
    // Alert player only when a system NEWLY fails (crossing threshold for the first time)
    if (!prevShieldsDown && ship.shieldsDown) addMessage('WARNING: SHIELDS DEGRADED');
    if (!prevWeaponsDown && ship.weaponsDown) addMessage('WARNING: WEAPONS DAMAGED');
    if (!prevEnginesDown && ship.enginesDown) addMessage('WARNING: ENGINES DAMAGED');
  }
}

function destroyShip(ship) {
  ship.alive = false;
  ship.warp = 0;
  if (ship.landedOn) ship.landedOn = null;

  SoundManager.shipDestroyed();

  // Create explosion flash effect (reuse phaserFX array with special marker)
  const fx = createPhaserFX(ship.x, ship.y, 0);
  fx.isExplosion = true;
  fx.ownerRace = ship.race;
  G.phaserFX.push(fx);

  if (ship.isPlayer) {
    G.score += SCORE_DEATH;
    G.gameWon = false;
    setTimeout(() => {
      G.cinematicText = 'Your ship drifts silent in the void. The war continues without you, Commander.';
      G.cinematicAge  = 0;
      G.phase = 'CINEMATIC';
    }, 1200);
  }
}

function toggleRepair(ship) {
  if (!ship.alive) return;
  const planet = getNearestPlanetInRange(ship, LAND_RANGE);
  if (!planet || planet.race !== ship.race) {
    if (ship.isPlayer) addMessage('MUST BE AT FRIENDLY PLANET TO REPAIR');
    return;
  }
  // If not landed yet, land first
  if (!ship.landedOn) {
    ship.landedOn = planet;
    ship.warp = 0;
  }
  ship.repairing = !ship.repairing;
  if (ship.isPlayer) addMessage(ship.repairing ? 'REPAIR SYSTEMS ONLINE' : 'REPAIR SYSTEMS OFFLINE');
}


// =============================================================
// SECTION 6: AI LOGIC
// =============================================================

function updateAI(ship, dt) {
  if (!ship.alive || !ship.ai) return;

  const ai = ship.ai;
  ai.decisionTimer -= dt;

  // Always execute current state behaviour every tick
  executeAIMovement(ship, dt);

  // Periodic decisions
  if (ai.decisionTimer > 0) return;
  ai.decisionTimer = AI_DECISION_RATE + Math.random() * 0.3;

  // Scan for nearest enemy ship
  let nearestEnemy = null, nearestEnemyDist = Infinity;
  for (const other of G.ships) {
    if (!other.alive || other.race === ship.race) continue;
    const d = toroidalDist(ship.x, ship.y, other.x, other.y);
    if (d < nearestEnemyDist) { nearestEnemyDist = d; nearestEnemy = other; }
  }

  // Scan for nearest enemy/neutral planet
  let nearestTargetPlanet = null, nearestTargetDist = Infinity;
  for (const planet of G.planets) {
    if (planet.race === ship.race) continue;
    const d = toroidalDist(ship.x, ship.y, planet.x, planet.y);
    if (d < nearestTargetDist) { nearestTargetDist = d; nearestTargetPlanet = planet; }
  }

  // Scan for nearest friendly planet (for retreat)
  let nearestFriendly = null, nearestFriendlyDist = Infinity;
  for (const planet of G.planets) {
    if (planet.race !== ship.race) continue;
    const d = toroidalDist(ship.x, ship.y, planet.x, planet.y);
    if (d < nearestFriendlyDist) { nearestFriendlyDist = d; nearestFriendly = planet; }
  }

  // State machine transitions
  switch (ai.state) {
    case 'PATROL':
      if (nearestEnemy && nearestEnemyDist < AI_SCAN_RADIUS && ship.hull > AI_ATTACK_HULL_MIN) {
        ai.state = 'ATTACK';
        ai.targetShip = nearestEnemy;
      } else if (ship.armies >= AI_ARMY_THRESHOLD && nearestTargetPlanet && nearestTargetDist < AI_SCAN_RADIUS * 1.5) {
        ai.state = 'CONQUER';
        ai.targetPlanet = nearestTargetPlanet;
      }
      break;

    case 'ATTACK':
      if (ship.hull <= AI_ATTACK_HULL_MIN || ship.energy < 150) {
        ai.state = 'RETREAT';
        ai.targetPlanet = nearestFriendly;
      } else if (!nearestEnemy || nearestEnemyDist > AI_SCAN_RADIUS * 1.5) {
        ai.state = 'PATROL';
        ai.targetShip = null;
        ai.waypointX = Math.random() * GRID_W;
        ai.waypointY = Math.random() * GRID_H;
      } else {
        ai.targetShip = nearestEnemy;
      }
      break;

    case 'RETREAT':
      if (!nearestFriendly) {
        ai.state = 'PATROL';
        break;
      }
      // Arrived at friendly planet?
      if (nearestFriendlyDist < LAND_RANGE) {
        ship.landedOn = nearestFriendly;
        ship.warp = 0;
        ship.repairing = true;
        // Wait until hull is recovered
        if (ship.hull > 80) {
          ship.landedOn = null;
          ship.repairing = false;
          ai.state = 'PATROL';
          ai.waypointX = Math.random() * GRID_W;
          ai.waypointY = Math.random() * GRID_H;
        }
      } else {
        ai.targetPlanet = nearestFriendly;
      }
      break;

    case 'CONQUER':
      // Interrupted by close enemy
      if (nearestEnemy && nearestEnemyDist < AI_SCAN_RADIUS * 0.6 && ship.hull > AI_ATTACK_HULL_MIN) {
        ai.state = 'ATTACK';
        ai.targetShip = nearestEnemy;
        break;
      }
      if (!nearestTargetPlanet) {
        ai.state = 'PATROL';
        break;
      }
      ai.targetPlanet = nearestTargetPlanet;

      // Attempt to beam if in range
      if (nearestTargetDist < LAND_RANGE && ship.armies > nearestTargetPlanet.defense) {
        beamDown(ship, nearestTargetPlanet);
        ai.state = 'PATROL';
        ai.waypointX = Math.random() * GRID_W;
        ai.waypointY = Math.random() * GRID_H;
      }
      break;
  }
}

function executeAIMovement(ship, dt) {
  if (ship.landedOn) return; // handled in updateShip

  const ai = ship.ai;

  // Heading and warp for each state
  switch (ai.state) {
    case 'PATROL': {
      const { dx, dy } = toroidalDelta(ship.x, ship.y, ai.waypointX, ai.waypointY);
      const desiredH = Math.atan2(dy, dx);
      turnToward(ship, desiredH, dt);
      ship.warp = 3;
      if (toroidalDist(ship.x, ship.y, ai.waypointX, ai.waypointY) < 3) {
        ai.waypointX = Math.random() * GRID_W;
        ai.waypointY = Math.random() * GRID_H;
      }
      break;
    }
    case 'ATTACK': {
      if (!ai.targetShip || !ai.targetShip.alive) {
        ai.state = 'PATROL';
        return;
      }
      const dist = toroidalDist(ship.x, ship.y, ai.targetShip.x, ai.targetShip.y);
      const { dx, dy } = toroidalDelta(ship.x, ship.y, ai.targetShip.x, ai.targetShip.y);
      turnToward(ship, Math.atan2(dy, dx), dt);
      ship.warp = dist > 20 ? 5 : (dist > 8 ? 3 : 1);

      // Fire weapons
      if (dist < PHASER_RANGE) firePhasers(ship);
      if (dist < TORPEDO_RANGE * 0.75 && ship.torpedoes > 0) fireTorpedo(ship);
      break;
    }
    case 'RETREAT': {
      if (!ai.targetPlanet) return;
      const { dx, dy } = toroidalDelta(ship.x, ship.y, ai.targetPlanet.x, ai.targetPlanet.y);
      turnToward(ship, Math.atan2(dy, dx), dt);
      ship.warp = 6;
      break;
    }
    case 'CONQUER': {
      if (!ai.targetPlanet) return;
      const dist = toroidalDist(ship.x, ship.y, ai.targetPlanet.x, ai.targetPlanet.y);
      const { dx, dy } = toroidalDelta(ship.x, ship.y, ai.targetPlanet.x, ai.targetPlanet.y);
      turnToward(ship, Math.atan2(dy, dx), dt);
      ship.warp = dist > 8 ? 4 : 1;
      break;
    }
  }
}

function turnToward(ship, desiredHeading, dt) {
  let diff = desiredHeading - ship.heading;
  while (diff >  Math.PI) diff -= Math.PI * 2;
  while (diff < -Math.PI) diff += Math.PI * 2;
  const maxTurn = TURN_RATE * dt * (ship.enginesDown ? 0.5 : 1);
  ship.heading += Math.sign(diff) * Math.min(Math.abs(diff), maxTurn);
  ship.heading = ((ship.heading % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
}


// =============================================================
// SECTION 7: PLANET SYSTEM
// =============================================================

function initPlanets() {
  const planets = [];
  const M = CORNER_MARGIN;

  // Home planet clusters: 3 per race, one at each corner
  // Federation=top-left, Romulan=top-right, Orion=bottom-left, Kazari=bottom-right
  const corners = [
    [RACES.FEDERATION, M,          M         ],
    [RACES.ROMULAN,    GRID_W - M, M         ],
    [RACES.ORION,      M,          GRID_H - M],
    [RACES.KAZARI,     GRID_W - M, GRID_H - M],
  ];
  // Small triangle offsets around corner centre
  const homeOffsets = [[0, 0], [7, -4], [-4, 7]];

  let id = 0;
  for (const [race, cx, cy] of corners) {
    for (const [ox, oy] of homeOffsets) {
      planets.push(createPlanet(id++, wrapCoord(cx + ox, GRID_W), wrapCoord(cy + oy, GRID_H), race, true));
    }
  }

  // 13 neutral planets, scattered with minimum spacing
  let attempts = 0;
  while (planets.length < NUM_PLANETS && attempts < 10000) {
    attempts++;
    // Bias toward the middle of the grid (avoid corners)
    const x = 20 + Math.random() * (GRID_W - 40);
    const y = 20 + Math.random() * (GRID_H - 40);
    let tooClose = false;
    for (const p of planets) {
      if (toroidalDist(x, y, p.x, p.y) < 14) { tooClose = true; break; }
    }
    if (!tooClose) {
      planets.push(createPlanet(id++, x, y, null, false));
    }
  }

  return planets;
}

function updatePlanets(dt) {
  for (const planet of G.planets) {
    // Army regeneration on owned planets
    if (planet.race !== null) {
      planet.armyRegenTimer -= dt;
      if (planet.armyRegenTimer <= 0) {
        planet.armyRegenTimer = ARMY_REGEN_INTERVAL;
        if (planet.armies < PLANET_ARMY_MAX) planet.armies++;
      }
    }

    // Flicker animation
    planet.flickerPhase += dt * 1.8;
  }
}

function getNearestPlanetInRange(ship, range) {
  let nearest = null, nearestDist = Infinity;
  for (const planet of G.planets) {
    const d = toroidalDist(ship.x, ship.y, planet.x, planet.y);
    if (d < range && d < nearestDist) { nearest = planet; nearestDist = d; }
  }
  return nearest;
}

function tryLand(ship) {
  if (!ship.alive) return;
  const planet = getNearestPlanetInRange(ship, LAND_RANGE);
  if (!planet) {
    if (ship.isPlayer) addMessage('NO PLANET IN RANGE TO LAND');
    return;
  }
  if (planet.race !== ship.race) {
    if (ship.isPlayer) addMessage('CANNOT LAND ON ENEMY PLANET — CONQUER IT FIRST');
    return;
  }
  ship.landedOn = planet;
  ship.warp = 0;
  if (ship.isPlayer) {
    SoundManager.landing();
    addMessage(`LANDED ON PLANET ${planet.id} (${RACE_NAMES[planet.race]})`);
  }
}

function tryBeam(ship) {
  if (!ship.alive) return;
  const planet = getNearestPlanetInRange(ship, LAND_RANGE);
  if (!planet) {
    if (ship.isPlayer) addMessage('NO PLANET IN BEAM RANGE');
    return;
  }
  beamDown(ship, planet);
}

function beamDown(ship, planet) {
  if (ship.armies <= 0) {
    if (ship.isPlayer) addMessage('NO ARMIES ABOARD');
    return;
  }

  const beamed = ship.armies;
  ship.armies = 0;

  if (planet.race === ship.race) {
    // Reinforce friendly planet
    planet.armies = Math.min(planet.armies + beamed, PLANET_ARMY_MAX);
    if (ship.isPlayer) addMessage(`REINFORCED PLANET ${planet.id} WITH ${beamed} ARMIES`);
  } else {
    // Assault: compare beamed armies vs planet defense
    const netForce = beamed - planet.defense;
    if (netForce > 0) {
      // Conquest!
      const prevRace = planet.race;
      planet.race = ship.race;
      planet.defense = Math.max(1, Math.floor(netForce / 2));
      planet.armies  = Math.floor(netForce / 2);
      if (ship.isPlayer) {
        G.score += SCORE_PLANET;
        SoundManager.planetConquered();
        addMessage(`PLANET ${planet.id} CONQUERED! +${SCORE_PLANET} PTS (was ${prevRace !== null ? RACE_NAMES[prevRace] : 'Neutral'})`);
      }
      checkWinCondition();
    } else {
      // Assault failed
      planet.defense -= beamed;
      if (ship.isPlayer) {
        G.score += SCORE_ARMY_LOST * beamed;
        G.armiesLost += beamed;
        addMessage(`ASSAULT FAILED — ${planet.defense} DEFENDERS REMAIN`);
      }
    }
  }
}

function checkWinCondition() {
  if (G.phase !== 'PLAYING') return; // prevent re-entry
  const allOwned = G.planets.every(p => p.race === G.playerRace);
  if (allOwned) {
    G.score += SCORE_WIN_BONUS;
    G.gameWon = true;
    G.phase = 'WIN'; // immediate so no further actions process
    addMessage(`ALL PLANETS CONQUERED — VICTORY! +${SCORE_WIN_BONUS} BONUS`);
    setTimeout(() => {
      if (G.phase === 'WIN') {
        G.cinematicText = `The galaxy bows to ${RACE_NAMES[G.playerRace]} supremacy. Your name will echo across the stars.`;
        G.cinematicAge  = 0;
        G.phase = 'CINEMATIC';
      }
    }, 2800);
  }
}

function addMessage(text, duration = 3.5) {
  G.messages.push({ text, age: 0, duration });
  if (G.messages.length > 6) G.messages.shift();
}


// =============================================================
// SECTION 7.5: HALL OF FAME SYSTEM
// =============================================================

function loadHof() {
  try {
    const raw = localStorage.getItem(HOF_KEY);
    G.hof = raw ? JSON.parse(raw) : [];
  } catch (e) {
    G.hof = [];
  }
}

function saveHofEntry(name) {
  const entry = {
    name: (name || 'ANONYMOUS').toUpperCase().slice(0, 12),
    score: G.score,
    race: G.playerRace,
    won: G.gameWon,
    date: new Date().toLocaleDateString(),
  };
  G.hof.push(entry);
  G.hof.sort((a, b) => b.score - a.score);
  if (G.hof.length > HOF_MAX) G.hof.length = HOF_MAX;
  try {
    localStorage.setItem(HOF_KEY, JSON.stringify(G.hof));
  } catch (e) { /* storage unavailable */ }
}

function commitNameEntry() {
  const name = G.nameText.trim() || 'ANONYMOUS';
  saveHofEntry(name);
  G.nameText = '';
  G.phase = 'HALL_OF_FAME';
  G.hofResumePhase = 'RACE_SELECT';
}

function openHallOfFame(resumePhase) {
  loadHof(); // refresh in case another tab updated it
  G.hofResumePhase = resumePhase || 'RACE_SELECT';
  G.phase = 'HALL_OF_FAME';
}

function dismissHallOfFame() {
  G.phase = G.hofResumePhase || 'RACE_SELECT';
  G.hofResumePhase = null;
}

// -------------------------------------------------------
// Fade helper — call startFade('TARGET') to cross-fade
// between screens. Optional callback fires at black.
// -------------------------------------------------------
function startFade(targetPhase, callback) {
  if (G.fadeDir !== 0) return; // already fading
  G.fadeTarget   = targetPhase;
  G.fadeCallback = callback || null;
  G.fadeDir      = -1; // fade out first
  G.fadeElapsed  = 0;
  G.fadeAlpha    = 0;
}

// -------------------------------------------------------
// Title-screen star field (slowly drifting down)
// -------------------------------------------------------
function initTitleStars() {
  G.titleStars = [];
  for (let i = 0; i < 180; i++) {
    G.titleStars.push({
      x:          Math.random() * VIEW_W,
      y:          Math.random() * VIEW_H,
      speed:      10 + Math.random() * 25,
      brightness: 0.1 + Math.random() * 0.6,
      size:       Math.random() < 0.12 ? 2 : 1,
    });
  }
}

function updateTitleStars(dt) {
  for (const s of G.titleStars) {
    s.y += s.speed * dt;
    if (s.y > VIEW_H) { s.y = 0; s.x = Math.random() * VIEW_W; }
  }
}

// -------------------------------------------------------
// TITLE SCREEN
// -------------------------------------------------------
function renderTitle(ctx) {
  const pal = PHOSPHOR[G.phosphorMode];
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, VIEW_W, VIEW_H);

  // Drifting stars
  for (const s of G.titleStars) {
    ctx.save();
    ctx.fillStyle = '#ffffff';
    ctx.globalAlpha = s.brightness;
    ctx.fillRect(Math.round(s.x), Math.round(s.y), s.size, s.size);
    ctx.restore();
  }

  // Sub-label above ASCII block art
  glowText(ctx, 'P  L  A  T  O', VIEW_W / 2, 72, 22, pal.primary, pal.glow, 'center');

  // ASCII block art for EMPIRE (5 rows, centered)
  const art = [
    '\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588    \u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588 ',
    '\u2588\u2588      \u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588      ',
    '\u2588\u2588\u2588\u2588\u2588   \u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588   ',
    '\u2588\u2588      \u2588\u2588  \u2588\u2588  \u2588\u2588 \u2588\u2588      \u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588      ',
    '\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588      \u2588\u2588 \u2588\u2588      \u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 ',
  ];
  const artSize = 13;
  const artStartY = 118;
  art.forEach((line, i) => {
    glowText(ctx, line, VIEW_W / 2, artStartY + i * (artSize + 4), artSize, pal.primary, pal.glow, 'center');
  });

  // Subtitle
  glowText(ctx, 'A faithful recreation of the classic PLATO system game (1973)',
    VIEW_W / 2, 310, 11, pal.dim, pal.dim, 'center');

  // Blinking "PRESS ENTER" prompt
  if (Math.floor(G.gameTime * 1.5) % 2 === 0) {
    glowText(ctx, 'PRESS  ENTER  TO BEGIN, COMMANDER',
      VIEW_W / 2, 390, 16, pal.primary, pal.glow, 'center');
  }

  // Instructions hint
  glowText(ctx, 'Press  I  for Instructions', VIEW_W / 2, 440, 11, pal.dim, pal.dim, 'center');

  // Credits at bottom
  glowText(ctx,
    'Original game by various PLATO authors  \u00b7  Web recreation by [YOUR NAME]',
    VIEW_W / 2, VIEW_H - 36, 10, pal.dim, pal.dim, 'center');

  drawScanlines(ctx);
}

// -------------------------------------------------------
// RACE SELECTION SCREEN (enhanced)
// -------------------------------------------------------
function renderRaceSelectMinimap() {
  // Always ensure minimap canvas is visible during race selection
  const mmEl = document.getElementById('minimapCanvas');
  if (mmEl) mmEl.style.display = 'block';
  const ctx = G.mmCtx;
  if (!ctx) return;
  const pal = PHOSPHOR[G.phosphorMode];
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, MM_SIZE, MM_CANVAS_H);

  // "SECTOR MAP" label
  ctx.save();
  ctx.fillStyle = pal.dim;
  ctx.font = '9px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('SECTOR MAP', MM_SIZE / 2, MM_LABEL_H - 3);
  ctx.restore();

  // Grid border
  ctx.save();
  ctx.strokeStyle = pal.dim;
  ctx.globalAlpha = 0.25;
  ctx.lineWidth = 1;
  ctx.strokeRect(1, MM_LABEL_H + 1, MM_SIZE - 2, MM_SIZE - 2);
  ctx.restore();

  // Home corner positions per race (approximate, pre-game)
  const M = CORNER_MARGIN;
  const homeCorners = [
    [M, M],                       // Federation TL
    [GRID_W - M, M],              // Romulan TR
    [M, GRID_H - M],              // Orion BL
    [GRID_W - M, GRID_H - M],     // Kazari BR
  ];

  for (let r = 0; r < 4; r++) {
    const [wx, wy] = homeCorners[r];
    const mx = wx * MM_SCALE;
    const my = MM_LABEL_H + wy * MM_SCALE;
    const isSelected = r === G.raceSelectHover;
    ctx.save();
    ctx.fillStyle = RACE_COLORS[r];
    ctx.globalAlpha = isSelected ? 1.0 : 0.3;
    ctx.shadowColor = RACE_COLORS[r];
    ctx.shadowBlur  = isSelected ? 8 : 0;
    ctx.beginPath();
    ctx.arc(mx, my, isSelected ? 5 : 3, 0, Math.PI * 2);
    ctx.fill();
    // Label
    ctx.font      = '8px monospace';
    ctx.textAlign = 'center';
    const lx = mx + (mx < MM_SIZE / 2 ? 14 : -14);
    const ly = my + (my < MM_CANVAS_H / 2 ? 10 : -5);
    ctx.fillText(RACE_LETTERS[r], lx, ly);
    ctx.restore();
  }
}

// -------------------------------------------------------
// INSTRUCTIONS SCREEN
// -------------------------------------------------------
const INSTRUCTIONS_PAGES = [
  // Page 0: Controls reference
  [
    ['KEYBOARD CONTROLS', null, 'header'],
    ['', null, 'gap'],
    ['MOVEMENT', null, 'section'],
    ['W / \u2191', 'Increase warp speed'],
    ['S / \u2193', 'Decrease warp speed'],
    ['A / \u2190', 'Turn left'],
    ['D / \u2192', 'Turn right'],
    ['1 \u2013 9', 'Set warp speed directly'],
    ['', null, 'gap'],
    ['COMBAT', null, 'section'],
    ['T', 'Fire torpedo'],
    ['P', 'Fire phasers'],
    ['Q', 'Arm self-destruct (Q again to confirm)'],
    ['', null, 'gap'],
    ['SHIP SYSTEMS', null, 'section'],
    ['L', 'Land on friendly planet'],
    ['B', 'Beam down armies'],
    ['R', 'Toggle repair mode (must be landed)'],
    ['', null, 'gap'],
    ['DISPLAY / MISC', null, 'section'],
    ['G', 'Toggle phosphor color'],
    ['M', 'Toggle mini-map'],
    ['H', 'Hall of Fame'],
    ['I', 'Instructions (this screen)'],
    ['V', 'Toggle mute  |  [ / ]  Volume'],
  ],
  // Page 1: Lore & objectives
  [
    ['OBJECTIVE', null, 'header'],
    ['', null, 'gap'],
    ['Conquer all 25 planets in the sector to achieve', null, 'lore'],
    ['galactic supremacy. Each race begins with three', null, 'lore'],
    ['home planets at their corner of the sector grid.', null, 'lore'],
    ['', null, 'gap'],
    ['THE FOUR RACES', null, 'section'],
    ['FEDERATION', 'Balanced defenders. Top-left corner.'],
    ['ROMULAN', '+20% speed, -15% hull. Top-right.'],
    ['ORION', '+25% weapon damage, -20% energy. Bottom-left.'],
    ['KAZARI', '+30% hull, -20% speed. Bottom-right.'],
    ['', null, 'gap'],
    ['SCORING', null, 'section'],
    ['+100', 'Per planet conquered'],
    ['+250', 'Per enemy ship destroyed'],
    ['+2000', 'Galaxy conquest bonus'],
    ['-5', 'Per army lost in failed assault'],
    ['-500', 'Ship destruction penalty'],
    ['', null, 'gap'],
    ['Press  H  at any time to view the Hall of Fame.', null, 'lore'],
  ],
];

function renderInstructions(ctx) {
  const pal  = PHOSPHOR[G.phosphorMode];
  const page = INSTRUCTIONS_PAGES[G.instructionsPage] || INSTRUCTIONS_PAGES[0];

  // Semi-transparent background so the game world shows through if paused
  ctx.fillStyle = 'rgba(0,0,0,0.92)';
  ctx.fillRect(0, 0, VIEW_W, VIEW_H);

  // Title bar
  glowText(ctx, `INSTRUCTIONS  \u2014  PAGE ${G.instructionsPage + 1} / 2`,
    VIEW_W / 2, 30, 14, pal.primary, pal.glow, 'center');

  // Content
  const colK = 140;   // key column x
  const colV = 310;   // value column x
  let y = 80;
  for (const row of page) {
    const [key, val, type] = row;
    if (type === 'header') {
      glowText(ctx, key, VIEW_W / 2, y, 16, pal.primary, pal.glow, 'center');
      y += 24;
    } else if (type === 'section') {
      glowText(ctx, key, colK, y, 12, pal.dim, pal.dim);
      y += 20;
    } else if (type === 'gap') {
      y += 8;
    } else if (type === 'lore') {
      glowText(ctx, key, VIEW_W / 2, y, 12, pal.primary, phosphorGlow(), 'center');
      y += 18;
    } else {
      glowText(ctx, key, colK, y, 13, pal.primary, pal.glow, 'right');
      if (val) glowText(ctx, val, colV, y, 12, pal.dim, pal.dim);
      y += 18;
    }
  }

  // Navigation hint
  glowText(ctx, '\u2190 \u2192  Change page    \u00b7    I or Esc  Dismiss',
    VIEW_W / 2, VIEW_H - 36, 11, pal.dim, pal.dim, 'center');
  glowText(ctx,
    G.instructionsPage === 0 ? '\u25ba  Page 2: Lore & Scoring' : '\u25c4  Page 1: Controls',
    VIEW_W / 2, VIEW_H - 18, 11, pal.dim, pal.dim, 'center');

  drawScanlines(ctx);
}

// -------------------------------------------------------
// CINEMATIC TEXT CRAWL (before NAME_ENTRY)
// -------------------------------------------------------
function renderCinematic(ctx) {
  const pal  = PHOSPHOR[G.phosphorMode];
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, VIEW_W, VIEW_H);

  const charsPerSec = 32;
  const visible = G.cinematicText.slice(0, Math.min(G.cinematicText.length, Math.floor(G.cinematicAge * charsPerSec)));

  // Word-wrap the visible text
  const words = visible.split(' ');
  const lines  = [];
  let cur = '';
  for (const w of words) {
    const candidate = cur ? cur + ' ' + w : w;
    if (candidate.length > 38) { lines.push(cur); cur = w; }
    else cur = candidate;
  }
  if (cur) lines.push(cur);

  const lineH  = 34;
  const totalH = lines.length * lineH;
  const startY = Math.round(VIEW_H / 2 - totalH / 2);

  lines.forEach((line, i) => {
    const fadeIn = Math.min(1, G.cinematicAge - i * 0.15);
    ctx.save();
    ctx.globalAlpha = Math.max(0, fadeIn);
    glowText(ctx, line, VIEW_W / 2, startY + i * lineH, 20, pal.primary, pal.glow, 'center');
    ctx.restore();
  });

  const allShown = visible.length >= G.cinematicText.length;
  if (allShown && G.cinematicAge > G.cinematicText.length / charsPerSec + 1.5) {
    if (Math.floor(G.gameTime * 2) % 2 === 0) {
      glowText(ctx, 'PRESS ANY KEY TO CONTINUE', VIEW_W / 2, VIEW_H - 55, 11, pal.dim, pal.dim, 'center');
    }
  }

  drawScanlines(ctx);
}

function renderNameEntry(ctx) {
  const pal = PHOSPHOR[G.phosphorMode];

  // Draw world underneath if game was in progress
  if (G.ships.length > 0) {
    drawStars(ctx);
    drawSectorGrid(ctx);
  }

  // Dark overlay
  ctx.fillStyle = 'rgba(0,0,0,0.88)';
  ctx.fillRect(0, 0, VIEW_W, VIEW_H);

  const cx = VIEW_W / 2;
  const won = G.gameWon;
  const titleColor = won ? '#ffdd44' : '#ff4444';
  const titleText  = won ? 'VICTORY!' : 'SHIP DESTROYED';
  const subText    = won ? 'THE GALAXY IS YOURS' : 'YOUR EMPIRE FALLS TO THE VOID';

  glowText(ctx, titleText, cx, 115, 38, titleColor, titleColor, 'center');
  glowText(ctx, subText,   cx, 168, 14, pal.primary, pal.glow,  'center');
  glowText(ctx, `FINAL SCORE: ${G.score}`, cx, 210, 18, pal.primary, pal.glow, 'center');

  const statsY = 244;
  const statsSpacing = 200;
  glowText(ctx, `PLANETS: ${G.planets.filter(p => p.race === G.playerRace).length}/25`, cx - statsSpacing, statsY, 12, pal.dim, pal.dim, 'center');
  glowText(ctx, `KILLS: ${G.kills}`,             cx,               statsY, 12, pal.dim, pal.dim, 'center');
  glowText(ctx, `ARMIES LOST: ${G.armiesLost}`,  cx + statsSpacing, statsY, 12, pal.dim, pal.dim, 'center');

  glowText(ctx, 'ENTER YOUR NAME FOR THE HALL OF FAME:', cx, 292, 13, pal.primary, pal.glow, 'center');

  // Name input box
  const boxW = 280, boxH = 38, boxX = cx - boxW / 2, boxY = 316;
  ctx.save();
  ctx.strokeStyle = pal.primary;
  ctx.lineWidth   = 1.5;
  ctx.shadowColor = pal.glow;
  ctx.shadowBlur  = 12;
  ctx.strokeRect(boxX, boxY, boxW, boxH);
  ctx.restore();

  const cursor = (Math.floor(G.gameTime * 2) % 2 === 0) ? '_' : ' ';
  glowText(ctx, G.nameText + cursor, cx, boxY + 10, 16, pal.primary, pal.glow, 'center');

  glowText(ctx, 'ENTER = CONFIRM  ·  MAX 12 CHARACTERS', cx, 376, 11, pal.dim, pal.dim, 'center');

  drawScanlines(ctx);
}

function renderHallOfFame(ctx) {
  const pal = PHOSPHOR[G.phosphorMode];
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, VIEW_W, VIEW_H);

  glowText(ctx, 'P L A T O   E M P I R E', VIEW_W / 2, 38,  13, pal.dim,     pal.dim,  'center');
  glowText(ctx, '═══  HALL OF FAME  ═══',  VIEW_W / 2, 64,  20, pal.primary, pal.glow, 'center');

  const tX = 100, tY = 118, rowH = 38;
  // Header
  glowText(ctx, 'RANK  NAME           RACE         SCORE    RESULT  DATE', tX, tY, 11, pal.dim, pal.dim);
  // Separator line
  ctx.save();
  ctx.strokeStyle = pal.dim;
  ctx.globalAlpha = 0.5;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(tX, tY + 16);
  ctx.lineTo(VIEW_W - tX, tY + 16);
  ctx.stroke();
  ctx.restore();

  if (G.hof.length === 0) {
    glowText(ctx, '( NO ENTRIES YET — BE THE FIRST! )', VIEW_W / 2, tY + 55, 13, pal.dim, pal.dim, 'center');
  } else {
    G.hof.forEach((entry, i) => {
      const y = tY + 26 + i * rowH;
      // Rank colour: gold / silver / bronze / normal
      const rankColor = i === 0 ? '#ffdd44' : i === 1 ? '#bbbbbb' : i === 2 ? '#cc8844' : pal.primary;
      const wlColor   = entry.won ? '#44ff88' : '#ff5555';
      const wlText    = entry.won ? 'VICTORY' : 'DEFEAT';
      const name  = (entry.name  || '???').padEnd(14).slice(0, 14);
      const race  = (RACE_NAMES[entry.race] || '?').toUpperCase().padEnd(12).slice(0, 12);
      const score = entry.score.toString().padStart(7);
      glowText(ctx, `  ${(i + 1).toString().padStart(2)}.  ${name}  ${race}  ${score}`, tX, y, 13, rankColor, rankColor);
      glowText(ctx, wlText,           tX + 540, y, 12, wlColor,   wlColor);
      glowText(ctx, entry.date || '', tX + 615, y, 11, pal.dim,   pal.dim);
    });
  }

  glowText(ctx, 'PRESS ANY KEY TO CONTINUE', VIEW_W / 2, VIEW_H - 55, 13, pal.primary, pal.glow, 'center');
  drawScanlines(ctx);
}


// =============================================================
// SECTION 8: RENDERING
// =============================================================

// --- Phosphor helpers ---

function phosphorPrimary() { return PHOSPHOR[G.phosphorMode].primary; }
function phosphorGlow()    { return PHOSPHOR[G.phosphorMode].glow; }
function phosphorDim()     { return PHOSPHOR[G.phosphorMode].dim; }

// Draw a glowing line (two-pass: soft glow + sharp core)
function glowLine(ctx, x1, y1, x2, y2, color, width, glowColor, blurRadius) {
  ctx.save();
  // Pass 1: wide soft glow
  ctx.beginPath();
  ctx.moveTo(x1, y1); ctx.lineTo(x2, y2);
  ctx.strokeStyle = glowColor || color;
  ctx.lineWidth = (width || 1) * 3.5;
  ctx.globalAlpha = 0.25;
  ctx.shadowColor = glowColor || color;
  ctx.shadowBlur  = (blurRadius || 12) * 1.5;
  ctx.stroke();
  // Pass 2: sharp bright core
  ctx.beginPath();
  ctx.moveTo(x1, y1); ctx.lineTo(x2, y2);
  ctx.strokeStyle = color;
  ctx.lineWidth = width || 1;
  ctx.globalAlpha = 1;
  ctx.shadowBlur  = blurRadius || 8;
  ctx.stroke();
  ctx.restore();
}

// Draw glowing arc/circle
function glowArc(ctx, cx, cy, r, a0, a1, color, width, glowColor) {
  ctx.save();
  ctx.beginPath();
  ctx.arc(cx, cy, r, a0, a1);
  ctx.strokeStyle = glowColor || color;
  ctx.lineWidth = (width || 1) * 3;
  ctx.globalAlpha = 0.2;
  ctx.shadowColor = glowColor || color;
  ctx.shadowBlur  = 18;
  ctx.stroke();

  ctx.beginPath();
  ctx.arc(cx, cy, r, a0, a1);
  ctx.strokeStyle = color;
  ctx.lineWidth = width || 1;
  ctx.globalAlpha = 1;
  ctx.shadowBlur  = 8;
  ctx.stroke();
  ctx.restore();
}

// Draw phosphor text (two-pass glow)
function glowText(ctx, text, x, y, size, color, glowColor, align) {
  ctx.save();
  ctx.font = `${size || 13}px monospace`;
  ctx.textAlign = align || 'left';
  ctx.textBaseline = 'top';
  const c = color || phosphorPrimary();
  const g = glowColor || phosphorGlow();

  // Glow pass
  ctx.fillStyle = g;
  ctx.globalAlpha = 0.55;
  ctx.shadowColor = g;
  ctx.shadowBlur  = 14;
  ctx.fillText(text, x, y);

  // Sharp pass
  ctx.fillStyle = c;
  ctx.globalAlpha = 1;
  ctx.shadowBlur  = 5;
  ctx.fillText(text, x, y);
  ctx.restore();
}

// --- Star field ---

function initStars() {
  G.stars = [];
  for (let i = 0; i < 220; i++) {
    G.stars.push({
      sx: Math.random() * VIEW_W,
      sy: Math.random() * VIEW_H,
      brightness: 0.15 + Math.random() * 0.5,
      size: Math.random() < 0.1 ? 2 : 1,
    });
  }
}

function drawStars(ctx) {
  const dim = phosphorDim();
  for (const s of G.stars) {
    ctx.save();
    ctx.globalAlpha = s.brightness;
    ctx.fillStyle = dim;
    ctx.fillRect(s.sx, s.sy, s.size, s.size);
    ctx.restore();
  }
}

// --- Sector grid ---

function drawSectorGrid(ctx) {
  const gridStep = 16; // world units per grid line
  const px = gridStep * PPU;
  const camX = G.player ? G.player.x : GRID_W / 2;
  const camY = G.player ? G.player.y : GRID_H / 2;
  const offX = ((camX % gridStep) * PPU);
  const offY = ((camY % gridStep) * PPU);

  ctx.save();
  ctx.strokeStyle = phosphorDim();
  ctx.globalAlpha = 0.12;
  ctx.lineWidth = 0.5;
  ctx.shadowBlur = 0;

  for (let x = VIEW_W / 2 - offX; x >= 0; x -= px)       { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, VIEW_H); ctx.stroke(); }
  for (let x = VIEW_W / 2 - offX + px; x < VIEW_W; x += px) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, VIEW_H); ctx.stroke(); }
  for (let y = VIEW_H / 2 - offY; y >= 0; y -= px)       { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(VIEW_W, y); ctx.stroke(); }
  for (let y = VIEW_H / 2 - offY + px; y < VIEW_H; y += px) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(VIEW_W, y); ctx.stroke(); }

  ctx.restore();
}

// --- Planet rendering ---

function drawPlanet(ctx, planet, sx, sy) {
  const raceColor = planet.race !== null ? RACE_COLORS[planet.race] : '#888888';
  const flicker = 0.82 + 0.18 * Math.sin(planet.flickerPhase);
  const r = 9; // radius in pixels

  ctx.save();
  ctx.globalAlpha = flicker;

  // Outer aura
  ctx.beginPath();
  ctx.arc(sx, sy, r * 2.2, 0, Math.PI * 2);
  ctx.strokeStyle = raceColor;
  ctx.lineWidth = 0.5;
  ctx.globalAlpha = 0.18 * flicker;
  ctx.shadowColor = raceColor;
  ctx.shadowBlur  = 22;
  ctx.stroke();

  // Main circle
  ctx.globalAlpha = flicker;
  glowArc(ctx, sx, sy, r, 0, Math.PI * 2, raceColor, 1.5, raceColor);

  // Home planet: extra ring
  if (planet.isHome) {
    glowArc(ctx, sx, sy, r + 5, 0, Math.PI * 2, raceColor, 0.8, raceColor);
  }

  ctx.restore();

  // Label: race letter and planet id
  const letter = planet.race !== null ? RACE_LETTERS[planet.race] : 'N';
  glowText(ctx, letter, sx, sy - 6, 10, raceColor, raceColor, 'center');
  glowText(ctx, String(planet.id), sx, sy + 4, 8, phosphorDim(), phosphorDim(), 'center');

  // Armies indicator (small)
  if (planet.armies > 0) {
    glowText(ctx, `[${planet.armies}]`, sx, sy + 14, 7, raceColor, raceColor, 'center');
  }
}

// --- Ship rendering ---

function drawShip(ctx, ship, sx, sy) {
  const raceColor = RACE_COLORS[ship.race];

  // Draw engine trail first (behind ship)
  for (let i = 0; i < ship.trail.length; i++) {
    const pt = ship.trail[i];
    const { sx: tsx, sy: tsy } = worldToScreen(pt.x, pt.y);
    const alpha = Math.max(0, 1 - pt.age / 1.2) * 0.6;
    if (alpha <= 0.02) continue;
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = raceColor;
    ctx.shadowColor = raceColor;
    ctx.shadowBlur = 5;
    const psize = 1 + (i / ship.trail.length) * 1.5;
    ctx.fillRect(tsx - psize / 2, tsy - psize / 2, psize, psize);
    ctx.restore();
  }

  // Ship body (triangle)
  const size = ship.isPlayer ? 13 : 10;
  ctx.save();
  ctx.translate(sx, sy);
  ctx.rotate(ship.heading);

  // Glow pass
  ctx.beginPath();
  ctx.moveTo(size, 0);
  ctx.lineTo(-size * 0.5,  size * 0.55);
  ctx.lineTo(-size * 0.28, 0);
  ctx.lineTo(-size * 0.5, -size * 0.55);
  ctx.closePath();
  ctx.strokeStyle = raceColor;
  ctx.lineWidth = ship.isPlayer ? 2 : 1.5;
  ctx.shadowColor = raceColor;
  ctx.shadowBlur = 14;
  ctx.globalAlpha = 1;
  ctx.stroke();

  // Shield indicator when shields are active (faint circle)
  if (!ship.shieldsDown && ship.shields > 20) {
    const shieldAlpha = ship.shields / 100 * 0.25;
    ctx.beginPath();
    ctx.arc(0, 0, size * 1.5, 0, Math.PI * 2);
    ctx.strokeStyle = raceColor;
    ctx.lineWidth = 1;
    ctx.globalAlpha = shieldAlpha;
    ctx.shadowBlur = 8;
    ctx.stroke();
  }

  ctx.restore();

  // Label for non-player ships
  if (!ship.isPlayer) {
    glowText(ctx, RACE_NAMES[ship.race][0], sx + 15, sy - 15, 9, raceColor, raceColor, 'left');
  } else {
    // Player crosshair indicator
    ctx.save();
    ctx.strokeStyle = phosphorPrimary();
    ctx.lineWidth = 0.5;
    ctx.globalAlpha = 0.25;
    ctx.shadowBlur = 0;
    ctx.beginPath(); ctx.moveTo(sx - 22, sy); ctx.lineTo(sx - 14, sy); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(sx + 14, sy); ctx.lineTo(sx + 22, sy); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(sx, sy - 22); ctx.lineTo(sx, sy - 14); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(sx, sy + 14); ctx.lineTo(sx, sy + 22); ctx.stroke();
    ctx.restore();
  }
}

// --- Torpedo rendering ---

function drawTorpedoes(ctx) {
  for (const torp of G.torpedoes) {
    const raceColor = RACE_COLORS[torp.ownerRace] || '#ffffff';
    drawAtWrapped(torp.x, torp.y, (sx, sy) => {
      // Bright core dot
      ctx.save();
      ctx.beginPath();
      ctx.arc(sx, sy, 3, 0, Math.PI * 2);
      ctx.fillStyle = '#ffffff';
      ctx.shadowColor = raceColor;
      ctx.shadowBlur  = 18;
      ctx.globalAlpha = 1;
      ctx.fill();

      // Trail line to previous position
      const { sx: px, sy: py } = worldToScreen(torp.prevX, torp.prevY);
      if (Math.hypot(sx - px, sy - py) < 60) { // don't draw across wrap seam
        ctx.beginPath();
        ctx.moveTo(px, py); ctx.lineTo(sx, sy);
        ctx.strokeStyle = raceColor;
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.6;
        ctx.shadowBlur = 10;
        ctx.stroke();
      }
      ctx.restore();
    });
  }
}

// --- Phaser / explosion FX ---

function drawPhaserFX(ctx) {
  for (const fx of G.phaserFX) {
    const t = fx.age / PHASER_FX_DURATION;
    const alpha = 1 - t;

    if (fx.isExplosion) {
      // Expanding ring for ship destruction
      const expT = fx.age / 1.0;
      const expAlpha = Math.max(0, 1 - expT);
      const expR = expT * 30 * PPU * 0.1; // expand to 3 world units in pixels
      drawAtWrapped(fx.x, fx.y, (sx, sy) => {
        ctx.save();
        ctx.globalAlpha = expAlpha * 0.9;
        ctx.beginPath();
        ctx.arc(sx, sy, expR, 0, Math.PI * 2);
        ctx.strokeStyle = RACE_COLORS[fx.ownerRace] || phosphorPrimary();
        ctx.lineWidth = 2;
        ctx.shadowColor = phosphorGlow();
        ctx.shadowBlur = 25;
        ctx.stroke();
        // Inner fill flash
        ctx.globalAlpha = expAlpha * 0.3;
        ctx.fillStyle = '#ffffff';
        ctx.fill();
        ctx.restore();
      });
      continue;
    }

    // Normal phaser cone
    drawAtWrapped(fx.x, fx.y, (sx, sy) => {
      ctx.save();
      ctx.translate(sx, sy);
      ctx.rotate(fx.heading);

      const range = PHASER_RANGE * PPU;
      const half  = PHASER_HALF_ANGLE;

      // Cone fill
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.arc(0, 0, range, -half, half);
      ctx.closePath();
      ctx.fillStyle = phosphorPrimary();
      ctx.globalAlpha = alpha * 0.18;
      ctx.shadowColor = phosphorGlow();
      ctx.shadowBlur  = 25;
      ctx.fill();

      // Cone outline
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.arc(0, 0, range, -half, half);
      ctx.closePath();
      ctx.strokeStyle = phosphorPrimary();
      ctx.lineWidth = 1;
      ctx.globalAlpha = alpha * 0.7;
      ctx.stroke();

      ctx.restore();
    });
  }
}

// --- Minimap (separate canvas) ---

function renderMinimap() {
  const ctx = G.mmCtx;
  if (!ctx || !G.minimapVisible) return;

  const S = MM_SIZE;
  const P = MM_LABEL_H;
  const W = S;
  const H = MM_CANVAS_H;

  // Clear to transparent so body background shows if desired
  ctx.clearRect(0, 0, W, H);

  // === "SECTOR MAP" label ===
  ctx.save();
  ctx.font = '9px monospace';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  // Glow pass
  ctx.fillStyle   = phosphorGlow();
  ctx.shadowColor = phosphorGlow();
  ctx.shadowBlur  = 10;
  ctx.globalAlpha = 0.7;
  ctx.fillText('SECTOR MAP', W / 2, 2);
  // Sharp pass
  ctx.fillStyle   = phosphorPrimary();
  ctx.shadowBlur  = 3;
  ctx.globalAlpha = 1;
  ctx.fillText('SECTOR MAP', W / 2, 2);
  ctx.restore();

  // === Map area background (semi-transparent black) ===
  ctx.save();
  ctx.fillStyle = 'rgba(0, 0, 0, 0.78)';
  ctx.fillRect(0, P, S, S);

  // Border (1px phosphor-colored)
  ctx.strokeStyle = phosphorPrimary();
  ctx.lineWidth   = 1;
  ctx.shadowColor = phosphorGlow();
  ctx.shadowBlur  = 5;
  ctx.globalAlpha = 0.9;
  ctx.strokeRect(0.5, P + 0.5, S - 1, S - 1);
  ctx.shadowBlur  = 0;
  ctx.globalAlpha = 1;

  // Clip all subsequent drawing to the map area
  ctx.beginPath();
  ctx.rect(0, P, S, S);
  ctx.clip();

  // === Planets ===
  for (const planet of G.planets) {
    const px = planet.x * MM_SCALE;
    const py = P + planet.y * MM_SCALE;

    let color, blur, dotR;
    if (planet.race === null) {
      // Neutral: dim grey
      color = '#555555'; blur = 1; dotR = 1.5;
    } else if (planet.race === G.playerRace) {
      // Player's race: full phosphor brightness
      color = phosphorPrimary(); blur = 5; dotR = planet.isHome ? 2.5 : 2;
    } else {
      // Enemy race: medium brightness in race color
      color = RACE_COLORS[planet.race]; blur = 3; dotR = planet.isHome ? 2 : 1.5;
    }

    ctx.beginPath();
    ctx.arc(px, py, dotR, 0, Math.PI * 2);
    ctx.fillStyle   = color;
    ctx.shadowColor = color;
    ctx.shadowBlur  = blur;
    ctx.fill();
  }

  ctx.shadowBlur = 0;

  // === AI ships (small triangles pointing in heading direction) ===
  for (const ship of G.ships) {
    if (!ship.alive || ship.isPlayer) continue;
    const sx = ship.x * MM_SCALE;
    const sy = P + ship.y * MM_SCALE;
    const color = RACE_COLORS[ship.race];
    const sz = 3.5; // triangle half-size in pixels

    ctx.save();
    ctx.translate(sx, sy);
    ctx.rotate(ship.heading);
    ctx.beginPath();
    ctx.moveTo( sz,    0);
    ctx.lineTo(-sz,  sz * 0.65);
    ctx.lineTo(-sz, -sz * 0.65);
    ctx.closePath();
    ctx.fillStyle   = color;
    ctx.shadowColor = color;
    ctx.shadowBlur  = 4;
    ctx.fill();
    ctx.restore();
  }

  // === Player ship (blinking + cross, independent 500 ms timer) ===
  if (G.player && G.player.alive) {
    const px = G.player.x * MM_SCALE;
    const py = P + G.player.y * MM_SCALE;
    const blinkOn = (Math.floor(Date.now() / 500) % 2) === 0;

    if (blinkOn) {
      const arm = 4.5;
      ctx.strokeStyle = '#ffffff';
      ctx.shadowColor = '#ffffff';
      ctx.shadowBlur  = 8;
      ctx.lineWidth   = 1.5;
      ctx.beginPath();
      ctx.moveTo(px - arm, py); ctx.lineTo(px + arm, py); // horizontal
      ctx.moveTo(px, py - arm); ctx.lineTo(px, py + arm); // vertical
      ctx.stroke();
    } else {
      // Dim cross when blink is off
      const arm = 3.5;
      ctx.strokeStyle = phosphorPrimary();
      ctx.shadowColor = phosphorPrimary();
      ctx.shadowBlur  = 3;
      ctx.lineWidth   = 1;
      ctx.globalAlpha = 0.5;
      ctx.beginPath();
      ctx.moveTo(px - arm, py); ctx.lineTo(px + arm, py);
      ctx.moveTo(px, py - arm); ctx.lineTo(px, py + arm);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }
  }

  // === Viewport rectangle (shows currently visible area) ===
  // Visible area in world units: VIEW_W/PPU = 40 wide, VIEW_H/PPU = 40 tall
  if (G.player) {
    const viewWWorld = VIEW_W / PPU; // 40
    const viewHWorld = VIEW_H / PPU; // 40
    const vpLeft  = G.player.x - viewWWorld / 2;
    const vpTop   = G.player.y - viewHWorld / 2;
    const vpW_mm  = viewWWorld * MM_SCALE;
    const vpH_mm  = viewHWorld * MM_SCALE;

    ctx.strokeStyle = phosphorPrimary();
    ctx.lineWidth   = 1;
    ctx.globalAlpha = 0.55;
    ctx.shadowBlur  = 0;
    ctx.setLineDash([3, 2]);

    // Draw rect pieces; try all 9 toroidal offset combinations so the rect
    // correctly wraps when the player is near a grid edge.
    for (let ox = -GRID_W; ox <= GRID_W; ox += GRID_W) {
      for (let oy = -GRID_H; oy <= GRID_H; oy += GRID_H) {
        const rx = (vpLeft + ox) * MM_SCALE;
        const ry = P + (vpTop  + oy) * MM_SCALE;
        // Reject pieces that don't overlap the map area at all
        if (rx + vpW_mm <= 0 || rx >= S)     continue;
        if (ry + vpH_mm <= P || ry >= P + S) continue;
        ctx.strokeRect(rx, ry, vpW_mm, vpH_mm);
      }
    }

    ctx.setLineDash([]);
    ctx.globalAlpha = 1;
  }

  ctx.restore(); // restore clip
}

// --- CRT scanlines ---

function drawScanlines(ctx) {
  ctx.save();
  ctx.globalAlpha = 0.035;
  ctx.fillStyle = '#000000';
  for (let y = 0; y < VIEW_H; y += 3) {
    ctx.fillRect(0, y, VIEW_W, 1);
  }
  ctx.restore();
}

// --- HUD rendering ---

function renderHUD() {
  const ctx = G.hudCtx;
  ctx.clearRect(0, 0, VIEW_W, HUD_H);

  // Background
  ctx.fillStyle = '#060606';
  ctx.fillRect(0, 0, VIEW_W, HUD_H);
  // Top border
  ctx.fillStyle = phosphorDim();
  ctx.globalAlpha = 0.5;
  ctx.fillRect(0, 0, VIEW_W, 1);
  ctx.globalAlpha = 1;

  if (G.phase !== 'PLAYING') return;

  const p = G.player;
  if (!p) return;

  const nearPlanet = getNearestPlanetInRange(p, ORBIT_RANGE);
  const headingDeg = Math.round(((p.heading * 180 / Math.PI) + 360)) % 360;

  // === Line 1: navigation / ship status ===
  const statusColor = phosphorPrimary();
  const dimColor    = phosphorDim();
  const flashOn = (Math.floor(G.gameTime * 2.5) % 2) === 0;

  // Sector coords
  glowText(ctx, `SEC:${Math.floor(p.x).toString().padStart(3,'0')},${Math.floor(p.y).toString().padStart(3,'0')}`, 8, 10, 12, statusColor);
  glowText(ctx, `HDG:${headingDeg.toString().padStart(3,'0')}°`, 128, 10, 12, statusColor);
  glowText(ctx, `WRP:${p.warp}`, 222, 10, 12, statusColor);

  // Hull bar
  const hullColor = p.hull > 50 ? statusColor : (p.hull > 25 ? '#ffaa00' : '#ff3333');
  glowText(ctx, `HUL:${Math.ceil(p.hull / (p.hullMax || 100) * 100).toString().padStart(3)}%`, 290, 10, 12, hullColor);

  // Shield
  const shldColor = p.shieldsDown ? (flashOn ? '#ff4444' : dimColor) : statusColor;
  glowText(ctx, `SHD:${Math.ceil(p.shields).toString().padStart(3)}%`, 375, 10, 12, shldColor);

  // Energy
  const enrgColor = p.energy < 200 ? (flashOn ? '#ff4444' : '#ffaa00') : statusColor;
  glowText(ctx, `NRG:${Math.floor(p.energy).toString().padStart(4)}`, 460, 10, 12, enrgColor);

  // Score
  glowText(ctx, `SCR:${G.score.toString().padStart(6)}`, 540, 10, 12, statusColor);
  // Race
  glowText(ctx, RACE_NAMES[G.playerRace].toUpperCase(), 680, 10, 12, RACE_COLORS[G.playerRace]);

  // === Line 2: weapons / armies / planet ===
  glowText(ctx, `TORP:${p.torpedoes.toString().padStart(2)}`, 8, 30, 12, statusColor);
  glowText(ctx, `ARMS:${p.armies.toString().padStart(2)}`, 90, 30, 12, statusColor);

  // Planet in range
  if (nearPlanet) {
    const pColor = nearPlanet.race !== null ? RACE_COLORS[nearPlanet.race] : '#aaaaaa';
    const pRace  = nearPlanet.race !== null ? RACE_NAMES[nearPlanet.race] : 'NEUTRAL';
    glowText(ctx, `PLN:${nearPlanet.id} [${pRace.toUpperCase()}] DEF:${nearPlanet.defense} ARM:${nearPlanet.armies}`, 170, 30, 12, pColor);
  } else {
    glowText(ctx, 'PLN: ---', 170, 30, 12, dimColor);
  }

  // Landed / repairing indicator
  if (p.landedOn) {
    const repStr = p.repairing ? '⚙ REPAIRING' : '⚓ LANDED';
    glowText(ctx, repStr, 520, 30, 12, '#44ff88');
  }

  // Self-destruct warning
  if (G.selfDestructArmed && flashOn) {
    glowText(ctx, '!! SELF-DESTRUCT ARMED !!', VIEW_W - 260, 30, 12, '#ff4444');
  }

  // === Line 3: damage warnings + messages ===
  const warnY = 52;
  let warnX = 8;
  if (p.shieldsDown && flashOn) {
    glowText(ctx, '!SHIELDS!', warnX, warnY, 11, '#ff4444'); warnX += 90;
  }
  if (p.weaponsDown && flashOn) {
    glowText(ctx, '!WEAPONS!', warnX, warnY, 11, '#ff4444'); warnX += 90;
  }
  if (p.enginesDown && flashOn) {
    glowText(ctx, '!ENGINES!', warnX, warnY, 11, '#ff4444'); warnX += 90;
  }

  // Latest message
  if (G.messages.length > 0) {
    const msg = G.messages[G.messages.length - 1];
    const fade = Math.max(0, 1 - msg.age / msg.duration);
    if (fade > 0.01) {
      ctx.save();
      ctx.globalAlpha = fade;
      glowText(ctx, '> ' + msg.text, Math.max(warnX + 10, 290), warnY, 11, phosphorPrimary());
      ctx.restore();
    }
  }
}

// --- Overlay screens ---

function renderRaceSelect(ctx) {
  const pal = PHOSPHOR[G.phosphorMode];
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, VIEW_W, VIEW_H);

  glowText(ctx, 'CHOOSE YOUR ALLEGIANCE', VIEW_W / 2, 36, 18, pal.primary, pal.glow, 'center');
  glowText(ctx, '\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500', VIEW_W / 2, 60, 11, pal.dim, pal.dim, 'center');

  // 2 × 2 grid layout
  const BOX_W = 340, BOX_H = 200;
  const COL_X = [36, VIEW_W - 36 - BOX_W];   // left edge of each column
  const ROW_Y = [80,  80 + BOX_H + 18];       // top edge of each row
  const ORDER = [0, 1, 2, 3];                  // race index order in grid

  ORDER.forEach(race => {
    const col    = race % 2;
    const row    = Math.floor(race / 2);
    const bx     = COL_X[col];
    const by     = ROW_Y[row];
    const color  = RACE_COLORS[race];
    const mod    = RACE_MODS[race];
    const isSelected = race === G.raceSelectHover;

    // Box border
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth   = isSelected ? 2 : 1;
    ctx.globalAlpha = isSelected ? 1.0 : 0.35;
    ctx.shadowColor = color;
    ctx.shadowBlur  = isSelected ? 16 : 0;
    ctx.strokeRect(bx, by, BOX_W, BOX_H);
    if (isSelected) {
      ctx.globalAlpha = 0.06;
      ctx.fillStyle   = color;
      ctx.fillRect(bx, by, BOX_W, BOX_H);
    }
    ctx.restore();

    const alpha = isSelected ? 1.0 : 0.5;
    ctx.save();
    ctx.globalAlpha = alpha;

    // Race name + digit key
    const raceName = RACE_NAMES[race].toUpperCase();
    glowText(ctx, `[${race + 1}]  ${raceName}`, bx + BOX_W / 2, by + 16, 16, color, color, 'center');

    // ASCII ship art (3 lines)
    RACE_SHIP_ART[race].forEach((line, li) => {
      glowText(ctx, line, bx + BOX_W / 2, by + 44 + li * 16, 13, color, color, 'center');
    });

    // Flavor description
    glowText(ctx, RACE_FLAVOR[race], bx + BOX_W / 2, by + 110, 11, pal.dim, pal.dim, 'center');

    // Stat bars (compact)
    const statY = by + 132;
    const stats = [
      { label: 'SPD', val: mod.speedMult },
      { label: 'HUL', val: mod.hullMult  },
      { label: 'WPN', val: mod.weaponMult },
      { label: 'NRG', val: mod.energyMult },
    ];
    stats.forEach((s, si) => {
      const sx = bx + 18 + si * 78;
      glowText(ctx, s.label, sx, statY, 10, pal.dim, pal.dim);
      // Simple bar
      const barW = 60, barH = 6;
      const filled = Math.round(barW * Math.min(s.val, 1.5) / 1.5);
      ctx.save();
      ctx.fillStyle = pal.dim;
      ctx.globalAlpha *= 0.4;
      ctx.fillRect(sx, statY + 13, barW, barH);
      ctx.fillStyle   = color;
      ctx.globalAlpha = alpha * (s.val >= 1 ? 1.0 : 0.6);
      ctx.shadowColor = color;
      ctx.shadowBlur  = 4;
      ctx.fillRect(sx, statY + 13, filled, barH);
      ctx.restore();
    });

    ctx.restore();
  });

  // Navigation / confirm hint
  glowText(ctx, '\u2190 \u2192  Navigate    \u00b7    Enter  Confirm    \u00b7    I  Instructions    \u00b7    H  Hall of Fame',
    VIEW_W / 2, VIEW_H - 32, 10, pal.dim, pal.dim, 'center');

  // Draw minimap preview
  renderRaceSelectMinimap();

  drawScanlines(ctx);
}

function renderEndScreen(ctx, won) {
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.82)';
  ctx.fillRect(0, 0, VIEW_W, VIEW_H);

  const msg   = won ? 'VICTORY' : 'SHIP DESTROYED';
  const sub   = won ? 'ALL PLANETS CONQUERED — THE GALAXY IS YOURS' : 'YOUR EMPIRE FALLS TO THE VOID';
  const color = won ? '#ffdd44' : '#ff4444';

  glowText(ctx, msg, VIEW_W / 2, VIEW_H / 2 - 60, 40, color, color, 'center');
  glowText(ctx, sub, VIEW_W / 2, VIEW_H / 2,       14, phosphorPrimary(), phosphorGlow(), 'center');
  glowText(ctx, `SCORE: ${G.score}`, VIEW_W / 2, VIEW_H / 2 + 44, 18, color, color, 'center');
  glowText(ctx, 'ENTERING HALL OF FAME...', VIEW_W / 2, VIEW_H / 2 + 80, 13, phosphorPrimary(), phosphorGlow(), 'center');
  glowText(ctx, '(PRESS ANY KEY TO CONTINUE)', VIEW_W / 2, VIEW_H / 2 + 102, 11, phosphorDim(), phosphorDim(), 'center');

  ctx.restore();
}

// --- Main render function ---

function render() {
  const ctx = G.ctx;

  // Clear
  ctx.clearRect(0, 0, VIEW_W, VIEW_H);
  ctx.fillStyle = '#000000';
  ctx.fillRect(0, 0, VIEW_W, VIEW_H);

  // --- Phase-specific screens ---
  if (G.phase === 'TITLE') {
    renderTitle(ctx);
    renderHUD();
  } else if (G.phase === 'RACE_SELECT') {
    renderRaceSelect(ctx);
    renderHUD();
  } else if (G.phase === 'INSTRUCTIONS') {
    // Show game world underneath if we came from PLAYING
    if (G.instructionsResume === 'PLAYING' && G.ships.length > 0) {
      drawStars(ctx);
      drawSectorGrid(ctx);
    }
    renderInstructions(ctx);
    renderHUD();
  } else if (G.phase === 'CINEMATIC') {
    renderCinematic(ctx);
    renderHUD();
  } else if (G.phase === 'NAME_ENTRY') {
    renderNameEntry(ctx);
    renderHUD();
  } else if (G.phase === 'HALL_OF_FAME') {
    renderHallOfFame(ctx);
    renderHUD();
  } else {
    // PLAYING / WIN
    drawStars(ctx);
    drawSectorGrid(ctx);

    for (const planet of G.planets) {
      drawAtWrapped(planet.x, planet.y, (sx, sy) => drawPlanet(ctx, planet, sx, sy));
    }

    drawPhaserFX(ctx);
    drawTorpedoes(ctx);

    for (const ship of G.ships) {
      if (!ship.alive) continue;
      drawAtWrapped(ship.x, ship.y, (sx, sy) => drawShip(ctx, ship, sx, sy));
    }

    renderMinimap();

    // Planet conquest progress
    const conquered = G.planets.filter(p => p.race === G.playerRace).length;
    glowText(ctx, `PLANETS: ${conquered}/25`, 8, 8, 11, phosphorDim());

    drawScanlines(ctx);

    // WIN: brief overlay before CINEMATIC transition
    if (G.phase === 'WIN') renderEndScreen(ctx, true);

    renderHUD();
  }

  // --- Fade overlay (drawn last, on top of everything) ---
  if (G.fadeAlpha > 0) {
    ctx.save();
    ctx.globalAlpha = G.fadeAlpha;
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, VIEW_W, VIEW_H);
    ctx.restore();
  }
}


// =============================================================
// SECTION 9: GAME LOOP & INIT
// =============================================================

function update(dt) {
  if (G.phase !== 'PLAYING') return;

  const p = G.player;

  // Player input (continuous turning)
  processInput(p, dt);

  // Self-destruct timer
  if (G.selfDestructArmed) {
    G.selfDestructTimer -= dt;
    if (G.selfDestructTimer <= 0) {
      G.selfDestructArmed = false;
      addMessage('SELF-DESTRUCT DISARMED');
    }
  }

  // Update all ships
  for (const ship of G.ships) {
    updateShip(ship, dt);
    if (!ship.isPlayer && ship.ai) updateAI(ship, dt);
  }

  // Torpedoes
  updateTorpedoes(dt);

  // Planets
  updatePlanets(dt);

  // Age phaser FX
  G.phaserFX = G.phaserFX.filter(fx => {
    fx.age += dt;
    const maxAge = fx.isExplosion ? 1.0 : PHASER_FX_DURATION;
    return fx.age < maxAge;
  });

  // Age messages
  G.messages = G.messages.filter(m => {
    m.age += dt;
    return m.age < m.duration;
  });

  // Low energy warning (hysteresis: start <20%, stop >25%)
  if (p.alive) {
    const energyPct = p.energy / ENERGY_MAX * 100;
    if (energyPct < 20 && !SoundManager.lowEnergyActive) {
      SoundManager.startLowEnergyWarning();
    } else if (energyPct > 25 && SoundManager.lowEnergyActive) {
      SoundManager.stopLowEnergyWarning();
    }
  }
}

function gameLoop(timestamp) {
  const rawDt = (timestamp - G.lastTimestamp) / 1000;
  G.lastTimestamp = timestamp;
  const dt = Math.min(rawDt, 0.1); // cap at 100ms

  G.gameTime += dt;

  // --- Title-screen drifting stars ---
  if (G.phase === 'TITLE') updateTitleStars(dt);

  // --- Cinematic age counter ---
  if (G.phase === 'CINEMATIC') {
    G.cinematicAge += dt;
    if (G.cinematicAge >= CINEMATIC_DURATION) {
      G.phase = 'NAME_ENTRY';
    }
  }

  // --- Fade transitions ---
  if (G.fadeDir !== 0) {
    G.fadeElapsed += dt;
    if (G.fadeDir === -1) {
      // Fading OUT → going to black
      G.fadeAlpha = Math.min(1, G.fadeElapsed / FADE_DURATION);
      if (G.fadeAlpha >= 1) {
        // Black: switch phase, fire callback
        if (G.fadeCallback) { G.fadeCallback(); G.fadeCallback = null; }
        if (G.fadeTarget)   { G.phase = G.fadeTarget; G.fadeTarget = null; }
        // Now fade IN
        G.fadeDir     = 1;
        G.fadeElapsed = 0;
      }
    } else {
      // Fading IN → clearing black
      G.fadeAlpha = Math.max(0, 1 - G.fadeElapsed / FADE_DURATION);
      if (G.fadeAlpha <= 0) G.fadeDir = 0;
    }
  }

  // --- Fixed physics steps (only while PLAYING) ---
  G.physicsAccum += dt;
  while (G.physicsAccum >= PHYSICS_STEP) {
    update(PHYSICS_STEP);
    G.physicsAccum -= PHYSICS_STEP;
  }

  render();
  requestAnimationFrame(gameLoop);
}

function startGame(playerRace) {
  G.playerRace = playerRace;
  G.phase = 'PLAYING';

  // Reset state
  G.ships     = [];
  G.planets   = [];
  G.torpedoes = [];
  G.phaserFX  = [];
  G.messages  = [];
  G.selfDestructArmed = false;
  G.gameTime  = 0;
  G.physicsAccum = 0;
  // Reset scoring stats
  G.score      = 0;
  G.kills      = 0;
  G.armiesLost = 0;
  G.gameWon    = false;
  G.nameText   = '';

  // Cancel any lingering low-energy warning from a previous game
  SoundManager.stopLowEnergyWarning();

  // Planet layout
  G.planets = initPlanets();

  // Home planet positions for each race (matching initPlanets corner logic)
  const M = CORNER_MARGIN;
  const homePos = [
    [M,          M         ],   // Federation: top-left
    [GRID_W - M, M         ],   // Romulan:    top-right
    [M,          GRID_H - M],   // Orion:      bottom-left
    [GRID_W - M, GRID_H - M],   // Kazari:     bottom-right
  ];

  // Player ship
  const [px, py] = homePos[playerRace];
  G.player = createShip(playerRace, px, py, true);
  G.ships.push(G.player);

  // AI ships (one per enemy race, start at their home corner)
  for (let race = 0; race < 4; race++) {
    if (race === playerRace) continue;
    const [ax, ay] = homePos[race];
    const aiShip = createShip(race, ax, ay, false);
    // AI ships start with a waypoint aimed away from their corner
    aiShip.ai.waypointX = GRID_W / 2 + (Math.random() - 0.5) * 60;
    aiShip.ai.waypointY = GRID_H / 2 + (Math.random() - 0.5) * 60;
    G.ships.push(aiShip);
  }

  addMessage(`EMPIRE ONLINE — ${RACE_NAMES[playerRace].toUpperCase()} COMMAND`);
  addMessage('CONQUER ALL 25 PLANETS TO WIN');
}

function init() {
  // Set up canvases
  const gameCanvas = document.getElementById('gameCanvas');
  const hudCanvas  = document.getElementById('hudCanvas');
  const mmCanvas   = document.getElementById('minimapCanvas');

  gameCanvas.width  = VIEW_W;
  gameCanvas.height = VIEW_H;
  hudCanvas.width   = VIEW_W;
  hudCanvas.height  = HUD_H;
  mmCanvas.width    = MM_SIZE;
  mmCanvas.height   = MM_CANVAS_H;

  G.ctx    = gameCanvas.getContext('2d');
  G.hudCtx = hudCanvas.getContext('2d');
  G.mmCtx  = mmCanvas.getContext('2d');

  // Crisp pixel rendering
  G.ctx.imageSmoothingEnabled    = false;
  G.hudCtx.imageSmoothingEnabled = false;
  G.mmCtx.imageSmoothingEnabled  = false;

  initStars();
  initTitleStars();
  loadHof();

  // Responsive scaling: CSS-transform the container to fill the window
  function handleResize() {
    const totalH = VIEW_H + HUD_H + 6;
    const scaleX = (window.innerWidth  - 10) / VIEW_W;
    const scaleY = (window.innerHeight - 10) / totalH;
    const scale  = Math.min(scaleX, scaleY);
    const el     = document.getElementById('gameContainer');
    if (el) el.style.transform = `scale(${scale})`;
  }
  window.addEventListener('resize', handleResize);
  handleResize();

  G.lastTimestamp = performance.now();
  requestAnimationFrame(gameLoop);
}

// Boot
window.addEventListener('load', init);
</script>
</body>
</html>
